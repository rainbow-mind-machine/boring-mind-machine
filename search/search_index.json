{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"boring-mind-machine \u00b6 boring mind machine is a set of boring base classes for building awesome bot flocks. Other mind machine libraries utilize the boring mind machine library's classes as a starting point for implementing bot flocks. For example, rainbow mind machine utilizes the TwitterKeymaker class defined in this library; embarcadero mind machine utilizes the GithubKeymaker class; and so on. All the shields \u00b6 Links \u00b6 boring mind machine (bmm) links: bmm source code on Github bmm documentation rainbow mind machine organization on Github releases: bmm releases on Github bmm on pypi bmm on dockerhub Pages \u00b6 About the Mind Machine Framework - general information about the mind machine framework (how does it work? what does it look like?) About Boring Mind Machine - about the boring mind machine library (what is it? what does it do?) Installing - installation instructions (how do I install bmm?) Quick Start - quick start instructions for getting started with boring mind machine base classes (how do I run bmm?) Documentation for components implemented in boring mind machine: Keymakers: bmm.BoringKeymaker bmm.BoringOAuthKeymaker bmm.GithubKeymaker bmm.GoogleKeymaker bmm.TwitterKeymaker bmm.BoringShepherd bmm.BoringSheep Future Work and Ideas (what's next for boring mind machine?) Credits Contributing Developer Notes - notes on processes for developers (how do I run tests, update packages/images, build documentation, etc.?)","title":"Home"},{"location":"#boring-mind-machine","text":"boring mind machine is a set of boring base classes for building awesome bot flocks. Other mind machine libraries utilize the boring mind machine library's classes as a starting point for implementing bot flocks. For example, rainbow mind machine utilizes the TwitterKeymaker class defined in this library; embarcadero mind machine utilizes the GithubKeymaker class; and so on.","title":"boring-mind-machine"},{"location":"#all-the-shields","text":"","title":"All the shields"},{"location":"#links","text":"boring mind machine (bmm) links: bmm source code on Github bmm documentation rainbow mind machine organization on Github releases: bmm releases on Github bmm on pypi bmm on dockerhub","title":"Links"},{"location":"#pages","text":"About the Mind Machine Framework - general information about the mind machine framework (how does it work? what does it look like?) About Boring Mind Machine - about the boring mind machine library (what is it? what does it do?) Installing - installation instructions (how do I install bmm?) Quick Start - quick start instructions for getting started with boring mind machine base classes (how do I run bmm?) Documentation for components implemented in boring mind machine: Keymakers: bmm.BoringKeymaker bmm.BoringOAuthKeymaker bmm.GithubKeymaker bmm.GoogleKeymaker bmm.TwitterKeymaker bmm.BoringShepherd bmm.BoringSheep Future Work and Ideas (what's next for boring mind machine?) Credits Contributing Developer Notes - notes on processes for developers (how do I run tests, update packages/images, build documentation, etc.?)","title":"Pages"},{"location":"about/","text":"About boring mind machine \u00b6 boring mind machine (bmm) is part of the mind machine suite of software, run by the rainbow-mind-machine organization on Github. Like all mind machines, boring mind machine is simple and extensible. How is boring mind machine simple? \u00b6 The mind machine framework revolves around providing a few simple components for building bot flocks: Keymaker classes Shepherd classes Sheep classes But it gets even simpler than that: boring-mind-machine provides a GithubKeymaker class , so that embarcadero mind machine can focus exclusively on Shepherd and Sheep classes. That's pretty simple! What does boring mind machine extend or do? \u00b6 The main job of boring mind machine is to take care of the boring stuff. That means two things: Setting up boring base classes that are designed to be extended by all of the other mind machine libraries; and Providing working OAuth Keymakers for every third-party service provider that has its own mind machine library. (Github, Google, Twitter, etc.) Base classes \u00b6 Because boring mind machine provides base classes, that means it does not extend classes - it provides the base classes that are extended. That makes boring mind machine unique among the mind machines - every mind machine library imports boring mind machine no matter what, and every Keymaker is defined in boring mind machine. OAuth Keymakers \u00b6 The second, most important functionality implemented in bmm are the Keymaker classes. bmm implements a Keymaker for each service that has a corresponding mind machine library. Collecting each Keymaker together makes the logic more clear. Each third party service implements the same authentication process (OAuth) but everybody does it differently, so there are many tedious, boring details to work out. Hence, the \"boring\". How is boring mind machine POOP-y? \u00b6 Libraries that implement good practices in POOP (Python Object Oriented Programming) are said to be POOP-y. What makes the boring mind machine library particularly POOP-y is the fact that it provides the solid foundation on which the entire mind machine enterprise is constructed. It is critical that the boring mind machine library be an exemplar of good practices for software built using the mind machine framework!","title":"About bmm"},{"location":"about/#about-boring-mind-machine","text":"boring mind machine (bmm) is part of the mind machine suite of software, run by the rainbow-mind-machine organization on Github. Like all mind machines, boring mind machine is simple and extensible.","title":"About boring mind machine"},{"location":"about/#how-is-boring-mind-machine-simple","text":"The mind machine framework revolves around providing a few simple components for building bot flocks: Keymaker classes Shepherd classes Sheep classes But it gets even simpler than that: boring-mind-machine provides a GithubKeymaker class , so that embarcadero mind machine can focus exclusively on Shepherd and Sheep classes. That's pretty simple!","title":"How is boring mind machine simple?"},{"location":"about/#what-does-boring-mind-machine-extend-or-do","text":"The main job of boring mind machine is to take care of the boring stuff. That means two things: Setting up boring base classes that are designed to be extended by all of the other mind machine libraries; and Providing working OAuth Keymakers for every third-party service provider that has its own mind machine library. (Github, Google, Twitter, etc.)","title":"What does boring mind machine extend or do?"},{"location":"about/#base-classes","text":"Because boring mind machine provides base classes, that means it does not extend classes - it provides the base classes that are extended. That makes boring mind machine unique among the mind machines - every mind machine library imports boring mind machine no matter what, and every Keymaker is defined in boring mind machine.","title":"Base classes"},{"location":"about/#oauth-keymakers","text":"The second, most important functionality implemented in bmm are the Keymaker classes. bmm implements a Keymaker for each service that has a corresponding mind machine library. Collecting each Keymaker together makes the logic more clear. Each third party service implements the same authentication process (OAuth) but everybody does it differently, so there are many tedious, boring details to work out. Hence, the \"boring\".","title":"OAuth Keymakers"},{"location":"about/#how-is-boring-mind-machine-poop-y","text":"Libraries that implement good practices in POOP (Python Object Oriented Programming) are said to be POOP-y. What makes the boring mind machine library particularly POOP-y is the fact that it provides the solid foundation on which the entire mind machine enterprise is constructed. It is critical that the boring mind machine library be an exemplar of good practices for software built using the mind machine framework!","title":"How is boring mind machine POOP-y?"},{"location":"bmm_keymaker/","text":"Boring Keymaker and Boring OAuth Keymaker \u00b6 There are two base Keymaker classes implemented by boring mind machine; they are BoringKeymaker and BoringOAuthKeymaker . Technically a Keymaker can inherit from BoringKeymaker and use any authentication method, but in practice all Keymakers are OAuth Keymakers. Constructing the Keymaker \u00b6 The generic BoringOAuthKeymaker class requires two bits of information: an API application token and an API application secret. These have different names for different services, so when you create a Keymaker, you need to specify the name of the token and the name of the secret in the Keymaker constructor: import boringmindmachine as bmm # create a dummy oauth keymaker class class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) For Github, Google, Twitter, etc. Keymakers, this value is already set. import boringmindmachine as bmm ghk = bmm . GithubKeymaker () gk = bmm . GoogleKeymaker () tk = bmm . TwitterKeymaker () Passing API Keys to the Keymaker \u00b6 The Keymaker must have client API keys to verify that it is in fact allowed to take actions as the third-party OAuth application. The API keys consist of a token and a secret that correspond to the OAuth app created for the third-party service. (For example, when you create a Github app, the app page will give a client ID and a client secret at the top of the page.) This token and secret can be passed three different ways: via environment variables via a JSON file via a Python dictionary Using Environment Variables \u00b6 To set using environment variables: use_env.py : import boringmindmachine as bmm class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) k . set_apikeys_env () This would then look for two environment variables corresponding to the name of the token and secret in all caps. In the above case, we would need to run the script and provide the API keys as follows: $ CLIENT_TOKEN=\"abcd\" CLIENT_SECRET=\"qwerty\" use_env.py Using JSON File \u00b6 To use a JSON file, create a simple JSON file with two key-value pairs. The two keys should be the token name and the secret name provided to the constructor. apikeys.json : { \"client_token\" : \"asdf\" , \"client_secret\" : \"qwerty\" } The corresponding call to set the Keymaker API tokens would look like: use_json.py : import boringmindmachine as bmm class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) k . set_apikeys_json ( 'apikeys.json' ) Using Python Dict \u00b6 use_dict.py : import boringmindmachine as bmm class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) k . set_apikeys_dict ({ 'client_token' : 'asdf' , 'client_secret' : 'qwerty' })","title":"Boring OAuth Keymaker"},{"location":"bmm_keymaker/#boring-keymaker-and-boring-oauth-keymaker","text":"There are two base Keymaker classes implemented by boring mind machine; they are BoringKeymaker and BoringOAuthKeymaker . Technically a Keymaker can inherit from BoringKeymaker and use any authentication method, but in practice all Keymakers are OAuth Keymakers.","title":"Boring Keymaker and Boring OAuth Keymaker"},{"location":"bmm_keymaker/#constructing-the-keymaker","text":"The generic BoringOAuthKeymaker class requires two bits of information: an API application token and an API application secret. These have different names for different services, so when you create a Keymaker, you need to specify the name of the token and the name of the secret in the Keymaker constructor: import boringmindmachine as bmm # create a dummy oauth keymaker class class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) For Github, Google, Twitter, etc. Keymakers, this value is already set. import boringmindmachine as bmm ghk = bmm . GithubKeymaker () gk = bmm . GoogleKeymaker () tk = bmm . TwitterKeymaker ()","title":"Constructing the Keymaker"},{"location":"bmm_keymaker/#passing-api-keys-to-the-keymaker","text":"The Keymaker must have client API keys to verify that it is in fact allowed to take actions as the third-party OAuth application. The API keys consist of a token and a secret that correspond to the OAuth app created for the third-party service. (For example, when you create a Github app, the app page will give a client ID and a client secret at the top of the page.) This token and secret can be passed three different ways: via environment variables via a JSON file via a Python dictionary","title":"Passing API Keys to the Keymaker"},{"location":"bmm_keymaker/#using-environment-variables","text":"To set using environment variables: use_env.py : import boringmindmachine as bmm class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) k . set_apikeys_env () This would then look for two environment variables corresponding to the name of the token and secret in all caps. In the above case, we would need to run the script and provide the API keys as follows: $ CLIENT_TOKEN=\"abcd\" CLIENT_SECRET=\"qwerty\" use_env.py","title":"Using Environment Variables"},{"location":"bmm_keymaker/#using-json-file","text":"To use a JSON file, create a simple JSON file with two key-value pairs. The two keys should be the token name and the secret name provided to the constructor. apikeys.json : { \"client_token\" : \"asdf\" , \"client_secret\" : \"qwerty\" } The corresponding call to set the Keymaker API tokens would look like: use_json.py : import boringmindmachine as bmm class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) k . set_apikeys_json ( 'apikeys.json' )","title":"Using JSON File"},{"location":"bmm_keymaker/#using-python-dict","text":"use_dict.py : import boringmindmachine as bmm class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) k . set_apikeys_dict ({ 'client_token' : 'asdf' , 'client_secret' : 'qwerty' })","title":"Using Python Dict"},{"location":"bmm_keymaker_github/","text":"Github Keymaker \u00b6 See examples/github/ . An example of creating a Github OAuth keymaker. This page gives an example of creating a Github OAuth Keymaker using the boring mind machine library. (Full Github bot functionality requires the embarcadero mind machine library .) Creating a Github App \u00b6 The brief summary of what we cover here: We need to create an application (something that will consume the API endpoints), and we need to grant the application access to at least one Github account. Set Up API and Create App \u00b6 To create an OAuth app as a user, see these detailed instructions from Github. When you create your OAuth app, the one crucial piece of information is the callback URL. This is where the magic token is sent once the user logs in with their Github account. The Github Keymaker runs a server on localhost port 8000, so the callback URL for your OAuth application should be set to http://localhost:8000 . Getting App Credentials \u00b6 Once you have created your application, the application's description page will contain the client ID and client secret needed to use this application to run mind machine bots using Github. Setting Github Credentials \u00b6 In the end you should have a pair of API keys (a client ID and a client secret), which you will pass to the keymaker using one of the three methods provided (via a dictionary, a JSON file, or environment variables). To run the Github Keymaker example, you need to pass the API keys to the keymaker using one of three methods: Using a dictionary Using a JSON file Using environment variables Environment Variables Example \u00b6 To use the environment variables option, you can run the Github Keymaker example program in examples/github/ like this: $ CLIENT_ID=\"...\" \\ CLIENT_SECRET=\"...\" \\ python github_auth.py Example Code \u00b6 github_auth.py : import boringmindmachine as bmm import subprocess keydir = 'keys' gk = bmm . GithubKeymaker () gk . set_apikeys_env () # Make the Github key print ( \"Creating a dummy key...\" ) gk . make_a_key ( 'dummy' , 'dummy.json' , keydir ) print ( \"Success.\" ) # Clean up the key # (remove this bit to keep the key around) print ( \"Cleaning up...\" ) subprocess . call ([ 'rm' , '-rf' , keydir ]) print ( \"Done.\" )","title":"Github Keymaker"},{"location":"bmm_keymaker_github/#github-keymaker","text":"See examples/github/ . An example of creating a Github OAuth keymaker. This page gives an example of creating a Github OAuth Keymaker using the boring mind machine library. (Full Github bot functionality requires the embarcadero mind machine library .)","title":"Github Keymaker"},{"location":"bmm_keymaker_github/#creating-a-github-app","text":"The brief summary of what we cover here: We need to create an application (something that will consume the API endpoints), and we need to grant the application access to at least one Github account.","title":"Creating a Github App"},{"location":"bmm_keymaker_github/#set-up-api-and-create-app","text":"To create an OAuth app as a user, see these detailed instructions from Github. When you create your OAuth app, the one crucial piece of information is the callback URL. This is where the magic token is sent once the user logs in with their Github account. The Github Keymaker runs a server on localhost port 8000, so the callback URL for your OAuth application should be set to http://localhost:8000 .","title":"Set Up API and Create App"},{"location":"bmm_keymaker_github/#getting-app-credentials","text":"Once you have created your application, the application's description page will contain the client ID and client secret needed to use this application to run mind machine bots using Github.","title":"Getting App Credentials"},{"location":"bmm_keymaker_github/#setting-github-credentials","text":"In the end you should have a pair of API keys (a client ID and a client secret), which you will pass to the keymaker using one of the three methods provided (via a dictionary, a JSON file, or environment variables). To run the Github Keymaker example, you need to pass the API keys to the keymaker using one of three methods: Using a dictionary Using a JSON file Using environment variables","title":"Setting Github Credentials"},{"location":"bmm_keymaker_github/#environment-variables-example","text":"To use the environment variables option, you can run the Github Keymaker example program in examples/github/ like this: $ CLIENT_ID=\"...\" \\ CLIENT_SECRET=\"...\" \\ python github_auth.py","title":"Environment Variables Example"},{"location":"bmm_keymaker_github/#example-code","text":"github_auth.py : import boringmindmachine as bmm import subprocess keydir = 'keys' gk = bmm . GithubKeymaker () gk . set_apikeys_env () # Make the Github key print ( \"Creating a dummy key...\" ) gk . make_a_key ( 'dummy' , 'dummy.json' , keydir ) print ( \"Success.\" ) # Clean up the key # (remove this bit to keep the key around) print ( \"Cleaning up...\" ) subprocess . call ([ 'rm' , '-rf' , keydir ]) print ( \"Done.\" )","title":"Example Code"},{"location":"bmm_keymaker_google/","text":"Google Keymaker \u00b6 See boring-mind-machine/examples/google . This page gives an example of creating a Google OAuth Keymaker using the boring mind machine library. (Full Google bot functionality requires one of the cheeseburger mind machine or papyrus mind machine or waxing gibbous mind machine libraries.) Creating a Google App \u00b6 The brief summary of what we cover here: We need to create an application (something that will consume the API endpoints), and we need to grant the application access to at least one Google account. Set Up API and Create App \u00b6 The first thing you must do is enable the APIs that you need. This may include the Drive, Calendar, or other APIs. You do this in the Google Cloud Platform (GCP) console . Go to the enable APIs page and select a project from the drop down menu. If you do not already have a project, go to the GCP console to create a new one before visiting the enable APIs link above. Creating App Credentials \u00b6 Now you will need to create OAuth credentials for your application. You can do this on the API Credentials page. To get there, click the three-stack menu (a.k.a. the \"hamburger\" menu) and scroll down to the Products section and click \"APIs and Services\". Now click the \"Credentials\" option on the left side. Now create your credentials. Create \"OAuth Client ID\" credentials. Use application type \"Other\". When you create the credentials, you will be given a client ID and a client secret. Copy these into a password manager or other location. Getting the App Credentials \u00b6 Once you've created the credentials, you can either copy-and-paste the client ID and client secret, or you can download them as a JSON file. To copy-and-paste, find the OAuth client credentials you created in the prior step and click the pencil icon on the right side. This will take you to a page with the client ID and client secret. To download as a JSON file, download credentials using the download button (down-arrow icon) on the right side. This JSON file contains all credential information (client ID and client secret). Rename it client_secret.json . End Result \u00b6 In the end you will have a JSON file with your OAuth application credentials in it, and these will be used to authenticate with the user. The Google OAuth process will load the keys from client_secret.json , and will open a login link for the user to authenticate with their Google account. The Google OAuth process also takes care of recieving the callback URL and the token contained in it, so the bot account keys are also stored in a JSON file. No environment variables need to be set, the only thing that needs to be set is the name of the JSON file containing the OAuth application's API credentials (should be client_secret.json ). Once you have client_secret.json in the current directory, you're set to go. Authorizing \u00b6 In the authorization step the Keymaker generates a login link/token for the user to visit and log in with their Google account. The user is then redirected back to the application with a token that can be used to perform actions on behalf of the account. Google requires the application's API keys to be provided via a JSON file on disk. To run the Google Keymaker example, specify the API key name in the google_auth.py script ( client_secret.json by default): $ python google_auth.py Example Code \u00b6 google_auth.py : import boringmindmachine as bmm import subprocess keydir = 'keys' gk = bmm . GoogleKeymaker () gk . set_apikeys_file ( 'client_secret.json' ) print ( \"Creating a dummy key...\" ) gk . make_a_key ( 'dummy' , 'dummy.json' , keydir ) print ( \"Success.\" ) print ( \"Cleaning up...\" ) subprocess . call ([ 'rm' , '-rf' , keydir ]) print ( \"Done.\" )","title":"Google Keymaker"},{"location":"bmm_keymaker_google/#google-keymaker","text":"See boring-mind-machine/examples/google . This page gives an example of creating a Google OAuth Keymaker using the boring mind machine library. (Full Google bot functionality requires one of the cheeseburger mind machine or papyrus mind machine or waxing gibbous mind machine libraries.)","title":"Google Keymaker"},{"location":"bmm_keymaker_google/#creating-a-google-app","text":"The brief summary of what we cover here: We need to create an application (something that will consume the API endpoints), and we need to grant the application access to at least one Google account.","title":"Creating a Google App"},{"location":"bmm_keymaker_google/#set-up-api-and-create-app","text":"The first thing you must do is enable the APIs that you need. This may include the Drive, Calendar, or other APIs. You do this in the Google Cloud Platform (GCP) console . Go to the enable APIs page and select a project from the drop down menu. If you do not already have a project, go to the GCP console to create a new one before visiting the enable APIs link above.","title":"Set Up API and Create App"},{"location":"bmm_keymaker_google/#creating-app-credentials","text":"Now you will need to create OAuth credentials for your application. You can do this on the API Credentials page. To get there, click the three-stack menu (a.k.a. the \"hamburger\" menu) and scroll down to the Products section and click \"APIs and Services\". Now click the \"Credentials\" option on the left side. Now create your credentials. Create \"OAuth Client ID\" credentials. Use application type \"Other\". When you create the credentials, you will be given a client ID and a client secret. Copy these into a password manager or other location.","title":"Creating App Credentials"},{"location":"bmm_keymaker_google/#getting-the-app-credentials","text":"Once you've created the credentials, you can either copy-and-paste the client ID and client secret, or you can download them as a JSON file. To copy-and-paste, find the OAuth client credentials you created in the prior step and click the pencil icon on the right side. This will take you to a page with the client ID and client secret. To download as a JSON file, download credentials using the download button (down-arrow icon) on the right side. This JSON file contains all credential information (client ID and client secret). Rename it client_secret.json .","title":"Getting the App Credentials"},{"location":"bmm_keymaker_google/#end-result","text":"In the end you will have a JSON file with your OAuth application credentials in it, and these will be used to authenticate with the user. The Google OAuth process will load the keys from client_secret.json , and will open a login link for the user to authenticate with their Google account. The Google OAuth process also takes care of recieving the callback URL and the token contained in it, so the bot account keys are also stored in a JSON file. No environment variables need to be set, the only thing that needs to be set is the name of the JSON file containing the OAuth application's API credentials (should be client_secret.json ). Once you have client_secret.json in the current directory, you're set to go.","title":"End Result"},{"location":"bmm_keymaker_google/#authorizing","text":"In the authorization step the Keymaker generates a login link/token for the user to visit and log in with their Google account. The user is then redirected back to the application with a token that can be used to perform actions on behalf of the account. Google requires the application's API keys to be provided via a JSON file on disk. To run the Google Keymaker example, specify the API key name in the google_auth.py script ( client_secret.json by default): $ python google_auth.py","title":"Authorizing"},{"location":"bmm_keymaker_google/#example-code","text":"google_auth.py : import boringmindmachine as bmm import subprocess keydir = 'keys' gk = bmm . GoogleKeymaker () gk . set_apikeys_file ( 'client_secret.json' ) print ( \"Creating a dummy key...\" ) gk . make_a_key ( 'dummy' , 'dummy.json' , keydir ) print ( \"Success.\" ) print ( \"Cleaning up...\" ) subprocess . call ([ 'rm' , '-rf' , keydir ]) print ( \"Done.\" )","title":"Example Code"},{"location":"bmm_keymaker_twitter/","text":"Twitter Keymaker \u00b6 See boring-mind-machine/examples/twitter . This page gives an example of creating a Twitter OAuth Keymaker using the boring mind machine library. (Full Twitter bot functionality requires the rainbow mind machine library .) Creating a Twitter App \u00b6 The brief summary of what we cover here: We need to create an application (something that will consume the API endpoints), and we need to grant the application access to at least one Twitter account. Set Up API and Create Twitter App \u00b6 See these Digital Ocean instructions that cover setting up the Twitter API and creating a Twitter OAuth application. Getting App Credentials \u00b6 Once you have created your Twitter app, visit the app page and look for the \"consumer token\" and \"consumer token secret\" (this is what Twitter calls the API application's token and secret). End result is you should have two pieces of information, which you can pass to the program using environment variables (easiest) or other methods. Authorizing \u00b6 In the authorization step, the TwitterKeymaker generates a login link/token for the user to visit and log in using their account. This then sends the user back to the application with a token. The user can provide the application API keys to the Keymaker via file, environment variable, or dictionary. The TwitterKeymaker will use the application API credentials and will guide the user through the process of authenticating. This uses Twitter's PIN-based authentication method. $ python twitter_auth.py Example Code \u00b6 twitter_auth.py : import boringmindmachine as bmm import subprocess keydir = 'keys' gk = bmm . TwitterKeymaker () gk . set_apikeys_file ( 'apikeys.json' ) # make the Twitter key print ( \"Creating a dummy key...\" ) gk . make_a_key ( 'dummy' , 'dummy.json' , keydir ) print ( \"Success.\" ) # Clean up the key # (remove this bit to keep the key around) print ( \"Cleaning up...\" ) subprocess . call ([ 'rm' , '-rf' , keydir ]) print ( \"Done.\" )","title":"Twitter Keymaker"},{"location":"bmm_keymaker_twitter/#twitter-keymaker","text":"See boring-mind-machine/examples/twitter . This page gives an example of creating a Twitter OAuth Keymaker using the boring mind machine library. (Full Twitter bot functionality requires the rainbow mind machine library .)","title":"Twitter Keymaker"},{"location":"bmm_keymaker_twitter/#creating-a-twitter-app","text":"The brief summary of what we cover here: We need to create an application (something that will consume the API endpoints), and we need to grant the application access to at least one Twitter account.","title":"Creating a Twitter App"},{"location":"bmm_keymaker_twitter/#set-up-api-and-create-twitter-app","text":"See these Digital Ocean instructions that cover setting up the Twitter API and creating a Twitter OAuth application.","title":"Set Up API and Create Twitter App"},{"location":"bmm_keymaker_twitter/#getting-app-credentials","text":"Once you have created your Twitter app, visit the app page and look for the \"consumer token\" and \"consumer token secret\" (this is what Twitter calls the API application's token and secret). End result is you should have two pieces of information, which you can pass to the program using environment variables (easiest) or other methods.","title":"Getting App Credentials"},{"location":"bmm_keymaker_twitter/#authorizing","text":"In the authorization step, the TwitterKeymaker generates a login link/token for the user to visit and log in using their account. This then sends the user back to the application with a token. The user can provide the application API keys to the Keymaker via file, environment variable, or dictionary. The TwitterKeymaker will use the application API credentials and will guide the user through the process of authenticating. This uses Twitter's PIN-based authentication method. $ python twitter_auth.py","title":"Authorizing"},{"location":"bmm_keymaker_twitter/#example-code","text":"twitter_auth.py : import boringmindmachine as bmm import subprocess keydir = 'keys' gk = bmm . TwitterKeymaker () gk . set_apikeys_file ( 'apikeys.json' ) # make the Twitter key print ( \"Creating a dummy key...\" ) gk . make_a_key ( 'dummy' , 'dummy.json' , keydir ) print ( \"Success.\" ) # Clean up the key # (remove this bit to keep the key around) print ( \"Cleaning up...\" ) subprocess . call ([ 'rm' , '-rf' , keydir ]) print ( \"Done.\" )","title":"Example Code"},{"location":"bmm_sheep/","text":"Boring Sheep \u00b6 (TODO: Copy Sheep materials over, and copy Shepherd docs) (TODO: What are the most common ways to extend Sheep? essential methods/call traces?) The Sheep is the class that represents a single user account on the third party service the mind machine is defining. In general, the pattern that mind machine bot flocks follow is: 1 Sheep = 1 bot account = 1 action. The BoringSheep class is really boring, because we don't want to impose restrictions or make assumptions by implementing a bunch of functionality. How to use the Boring Sheep class? (...don't) \u00b6 The constructor is where you create the Sheep's API instance, and should be defined at the package level. The Boring Sheep class has a virtual constructor, so it cannot be created directly. You should instead define a new Sheep class that inherits from Boring Sheep and defines a constructor, which should initialize an API instance. How to extend the Boring Sheep class? \u00b6 See the examples/ directory. What does the Boring Sheep class define? \u00b6 In addition to mentioning what you have to define, let's mention what you don't have to define. The Boring Sheep class implements a dispatcher pattern, which is a way of passing the name of an action as a string, and turning that into a function call. For example, if the user asks for the 'dummy' action via sheep.perform_action('dummy',**kwargs) , this will call sheep.dummy(**kwargs) . See command pattern (wikipedia) for a detailed description of the dispatcher pattern. def perform_action ( self , action , ** kwargs ): # Dispatcher pattern if hasattr ( self , action ): method = getattr ( self , action ) method ( ** kwargs )","title":"Boring Sheep"},{"location":"bmm_sheep/#boring-sheep","text":"(TODO: Copy Sheep materials over, and copy Shepherd docs) (TODO: What are the most common ways to extend Sheep? essential methods/call traces?) The Sheep is the class that represents a single user account on the third party service the mind machine is defining. In general, the pattern that mind machine bot flocks follow is: 1 Sheep = 1 bot account = 1 action. The BoringSheep class is really boring, because we don't want to impose restrictions or make assumptions by implementing a bunch of functionality.","title":"Boring Sheep"},{"location":"bmm_sheep/#how-to-use-the-boring-sheep-class-dont","text":"The constructor is where you create the Sheep's API instance, and should be defined at the package level. The Boring Sheep class has a virtual constructor, so it cannot be created directly. You should instead define a new Sheep class that inherits from Boring Sheep and defines a constructor, which should initialize an API instance.","title":"How to use the Boring Sheep class? (...don't)"},{"location":"bmm_sheep/#how-to-extend-the-boring-sheep-class","text":"See the examples/ directory.","title":"How to extend the Boring Sheep class?"},{"location":"bmm_sheep/#what-does-the-boring-sheep-class-define","text":"In addition to mentioning what you have to define, let's mention what you don't have to define. The Boring Sheep class implements a dispatcher pattern, which is a way of passing the name of an action as a string, and turning that into a function call. For example, if the user asks for the 'dummy' action via sheep.perform_action('dummy',**kwargs) , this will call sheep.dummy(**kwargs) . See command pattern (wikipedia) for a detailed description of the dispatcher pattern. def perform_action ( self , action , ** kwargs ): # Dispatcher pattern if hasattr ( self , action ): method = getattr ( self , action ) method ( ** kwargs )","title":"What does the Boring Sheep class define?"},{"location":"bmm_shepherd/","text":"Boring Shepherd \u00b6 The Shepherd class spins up the flock of Sheep and lets them roam free. The BoringShepherd class leaves the details of creating Sheep to the user, but still defines some useful methods. The constructor calls a method to setup the flock. The method to setup the flock loops over each key. For each key, it: validates the key creates a Sheep from the key There are also two methods to perform actions with the flock: one for serial and one for parallel. Constructor \u00b6 This defines a generic Shepherd constructor that takes the following parameters: json_keys_dir : Directory where Sheep API keys are located flock_name : The name of the bot flock (used to format log messages) sheep_class : Type of Sheep **kwargs : Logging parameters passed directly to Lumberjack logger Example: Suppose we have the following directory structure: $ ls keys/ bot_key1.json bot_key2.json bot_key3.json Constructor Call Order \u00b6 The call order for the constructor is as follows: Shepherd contructor calls create_flock() method create_flock() method loads each key in a directory and calls two methods: Private method _validate_key() is called to check the bot key Private method _create_sheep() is called to create the Sheep To extend the BoringShepherd class, you must extend both the _create_sheep() and _validate_key() classes (they are undefined/virtual methods in the base class). Example: Suppose we have the following directory structure: $ ls keys/ bot_key1.json bot_key2.json bot_key3.json Now we create a custom Shepherd class that extends the _create_sheep() and _validate_key() methods, and use the custom Shepherd class to (We illustrate performing basic key validation by checking for keys with a particular name.) import boringmindmachine as bmm class BlueShepherd ( bmm . BoringShepherd ): def _validate_key ( self , bot_key , ** kwargs ): \"\"\" Validate a bot key, passed in as a dictionary. Sole purpose of this function: raise an exception if there is a problem. \"\"\" required_keys = [ 'key1' , 'key2' , 'key3' ] for key in required_keys : if key not in bot_key . keys (): err = \"ERROR: the bot key is missing a required key ' %s '.\" % ( key ) raise Exception ( err ) def _create_sheep ( self ): sheep = self . sheep_class ( bot_key ) self . flock . append ( sheep ) Performing Actions \u00b6 The Shepherd and Sheep use the dispatcher pattern to call methods. The dispatcher pattern is used to turn a string (like \"tweet\") into a function call (like tweet() ). import boringmindmachine as bmm import time class FlatulentSheep ( bmm . BoringSheep ): def pass_gas ( self ): print ( \"pfffft\" ) time . sleep ( 30 ) if __name__ == \"__name__\" : s = bmm . BoringShepherd ( keys_dir = \"keys/\" , flock_name = \"flatulent_flock\" , sheep_class = FlatulentSheep ) s . perform_parallel_action ( 'pass_gas' ) Adding Parameters to Actions \u00b6 If we wanted to add a parameter with a default value (for example, the string being printed by pass_gas() ), we can use **kwargs as follows; import boringmindmachine as bmm import time class FlatulentSheep ( bmm . BoringSheep ): def pass_gas ( self ,, ** kwargs ): if 'message' in kwargs : msg = kwargs [ 'message' ] else : msg = 'pfffffft' print ( msg ) time . sleep ( 30 ) if __name__ == \"__name__\" : s = bmm . BoringShepherd ( keys_dir = \"keys/\" , flock_name = \"flatulent_flock\" , sheep_class = FlatulentSheep ) s . perform_parallel_action ( 'pass_gas' , message = 'FFFRRRRRRRRRAAAAAAAPPPPPPP' )","title":"Boring Shepherd"},{"location":"bmm_shepherd/#boring-shepherd","text":"The Shepherd class spins up the flock of Sheep and lets them roam free. The BoringShepherd class leaves the details of creating Sheep to the user, but still defines some useful methods. The constructor calls a method to setup the flock. The method to setup the flock loops over each key. For each key, it: validates the key creates a Sheep from the key There are also two methods to perform actions with the flock: one for serial and one for parallel.","title":"Boring Shepherd"},{"location":"bmm_shepherd/#constructor","text":"This defines a generic Shepherd constructor that takes the following parameters: json_keys_dir : Directory where Sheep API keys are located flock_name : The name of the bot flock (used to format log messages) sheep_class : Type of Sheep **kwargs : Logging parameters passed directly to Lumberjack logger Example: Suppose we have the following directory structure: $ ls keys/ bot_key1.json bot_key2.json bot_key3.json","title":"Constructor"},{"location":"bmm_shepherd/#constructor-call-order","text":"The call order for the constructor is as follows: Shepherd contructor calls create_flock() method create_flock() method loads each key in a directory and calls two methods: Private method _validate_key() is called to check the bot key Private method _create_sheep() is called to create the Sheep To extend the BoringShepherd class, you must extend both the _create_sheep() and _validate_key() classes (they are undefined/virtual methods in the base class). Example: Suppose we have the following directory structure: $ ls keys/ bot_key1.json bot_key2.json bot_key3.json Now we create a custom Shepherd class that extends the _create_sheep() and _validate_key() methods, and use the custom Shepherd class to (We illustrate performing basic key validation by checking for keys with a particular name.) import boringmindmachine as bmm class BlueShepherd ( bmm . BoringShepherd ): def _validate_key ( self , bot_key , ** kwargs ): \"\"\" Validate a bot key, passed in as a dictionary. Sole purpose of this function: raise an exception if there is a problem. \"\"\" required_keys = [ 'key1' , 'key2' , 'key3' ] for key in required_keys : if key not in bot_key . keys (): err = \"ERROR: the bot key is missing a required key ' %s '.\" % ( key ) raise Exception ( err ) def _create_sheep ( self ): sheep = self . sheep_class ( bot_key ) self . flock . append ( sheep )","title":"Constructor Call Order"},{"location":"bmm_shepherd/#performing-actions","text":"The Shepherd and Sheep use the dispatcher pattern to call methods. The dispatcher pattern is used to turn a string (like \"tweet\") into a function call (like tweet() ). import boringmindmachine as bmm import time class FlatulentSheep ( bmm . BoringSheep ): def pass_gas ( self ): print ( \"pfffft\" ) time . sleep ( 30 ) if __name__ == \"__name__\" : s = bmm . BoringShepherd ( keys_dir = \"keys/\" , flock_name = \"flatulent_flock\" , sheep_class = FlatulentSheep ) s . perform_parallel_action ( 'pass_gas' )","title":"Performing Actions"},{"location":"bmm_shepherd/#adding-parameters-to-actions","text":"If we wanted to add a parameter with a default value (for example, the string being printed by pass_gas() ), we can use **kwargs as follows; import boringmindmachine as bmm import time class FlatulentSheep ( bmm . BoringSheep ): def pass_gas ( self ,, ** kwargs ): if 'message' in kwargs : msg = kwargs [ 'message' ] else : msg = 'pfffffft' print ( msg ) time . sleep ( 30 ) if __name__ == \"__name__\" : s = bmm . BoringShepherd ( keys_dir = \"keys/\" , flock_name = \"flatulent_flock\" , sheep_class = FlatulentSheep ) s . perform_parallel_action ( 'pass_gas' , message = 'FFFRRRRRRRRRAAAAAAAPPPPPPP' )","title":"Adding Parameters to Actions"},{"location":"contributing/","text":"Contributing \u00b6 Ways to Contribute \u00b6 Some ways that you can contribute, in order of increasing involvement: Read the documentation ! If you find a problem or can't understand something, open an issue (see below). Use boring mind machine! You can test it out and come up with new ideas and ways of using boring mind machine. Open an issue in the boring mind machine repository on Github. The issue can be a bug, a question, an idea, or anything else. Fork boring mind machine on Github!","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#ways-to-contribute","text":"Some ways that you can contribute, in order of increasing involvement: Read the documentation ! If you find a problem or can't understand something, open an issue (see below). Use boring mind machine! You can test it out and come up with new ideas and ways of using boring mind machine. Open an issue in the boring mind machine repository on Github. The issue can be a bug, a question, an idea, or anything else. Fork boring mind machine on Github!","title":"Ways to Contribute"},{"location":"credits/","text":"Credits \u00b6 (TODO: add credits) Photo credits: keymaker.jpg - Russ Loar , released under the CC BY-NC-ND License","title":"Credits"},{"location":"credits/#credits","text":"(TODO: add credits) Photo credits: keymaker.jpg - Russ Loar , released under the CC BY-NC-ND License","title":"Credits"},{"location":"future/","text":"Future Work and Ideas \u00b6 (TODO: add future work and ideas)","title":"Future Work and Ideas"},{"location":"future/#future-work-and-ideas","text":"(TODO: add future work and ideas)","title":"Future Work and Ideas"},{"location":"installing/","text":"Installing \u00b6 Installing embarcadero mind machine \u00b6 To install embarcadero mind machine manually, use the normal setup.py procedure: git clone https://github.com/rainbow-mind-machine/embarcadero-mind-machine.git cd embarcadero-mind-machine python setup.py build python setup.py install To install embarcadero mind machine with pip: pip install embarcaderomindmachine Required Packages \u00b6 If you need a list of required packages, see requirements.txt . These packages will be installed using either of the above installation methods.","title":"Installing bmm"},{"location":"installing/#installing","text":"","title":"Installing"},{"location":"installing/#installing-embarcadero-mind-machine","text":"To install embarcadero mind machine manually, use the normal setup.py procedure: git clone https://github.com/rainbow-mind-machine/embarcadero-mind-machine.git cd embarcadero-mind-machine python setup.py build python setup.py install To install embarcadero mind machine with pip: pip install embarcaderomindmachine","title":"Installing embarcadero mind machine"},{"location":"installing/#required-packages","text":"If you need a list of required packages, see requirements.txt . These packages will be installed using either of the above installation methods.","title":"Required Packages"},{"location":"quickstart/","text":"Quick Start with Boring Mind Machine \u00b6 Here is a bare minimum example import boringmindmachine as bmm import os, tempfile token_var = 'token' secret_var = 'secret' keys_json = \"fake_apikeys.json\" keypath = os.path.join(os.getcwd(),keys_json) bk = bmm.BoringOAuthKeymaker(token=token_var, secret=secret_var) bk.set_apikeys_file(keypath) See the examples/ directory for additional examples.","title":"Quick Start"},{"location":"quickstart/#quick-start-with-boring-mind-machine","text":"Here is a bare minimum example import boringmindmachine as bmm import os, tempfile token_var = 'token' secret_var = 'secret' keys_json = \"fake_apikeys.json\" keypath = os.path.join(os.getcwd(),keys_json) bk = bmm.BoringOAuthKeymaker(token=token_var, secret=secret_var) bk.set_apikeys_file(keypath) See the examples/ directory for additional examples.","title":"Quick Start with Boring Mind Machine"},{"location":"mind-machine-docs/about/","text":"Mind Machine Framework \u00b6 The mind machine framework is designed to be a simple, extensible framework for developing bots. How is it simple? \u00b6 The mind machine concept is simple because there are only three components: Keymaker Sheep Shepherd These are the three types of objects that you deal with in any given mind machine (and you should not have to deal with the Keymaker much). How is it extensible? \u00b6 The concept of \"extensible\" refers specifically to the use of inheritance and extended classes. We want to keep things as simple as possible, but also build functionality up into complicated bots. Using base classes and extending one bit at a time helps us accomplish that. How is it POOP-y? \u00b6 The mind machine libraries are a great illustration of Python Object-Oriented Programming (POOP) in action. These are very POOP-y libraries, in that they use classes to combine minimal functionality into classes. We will point out the many examples of POOP-y behavior when we see them in a particular mind machine example. Deep Thoughts \u00b6 Foucault Motivations Naming things","title":"About Mind Machine Framework"},{"location":"mind-machine-docs/about/#mind-machine-framework","text":"The mind machine framework is designed to be a simple, extensible framework for developing bots.","title":"Mind Machine Framework"},{"location":"mind-machine-docs/about/#how-is-it-simple","text":"The mind machine concept is simple because there are only three components: Keymaker Sheep Shepherd These are the three types of objects that you deal with in any given mind machine (and you should not have to deal with the Keymaker much).","title":"How is it simple?"},{"location":"mind-machine-docs/about/#how-is-it-extensible","text":"The concept of \"extensible\" refers specifically to the use of inheritance and extended classes. We want to keep things as simple as possible, but also build functionality up into complicated bots. Using base classes and extending one bit at a time helps us accomplish that.","title":"How is it extensible?"},{"location":"mind-machine-docs/about/#how-is-it-poop-y","text":"The mind machine libraries are a great illustration of Python Object-Oriented Programming (POOP) in action. These are very POOP-y libraries, in that they use classes to combine minimal functionality into classes. We will point out the many examples of POOP-y behavior when we see them in a particular mind machine example.","title":"How is it POOP-y?"},{"location":"mind-machine-docs/about/#deep-thoughts","text":"Foucault Motivations Naming things","title":"Deep Thoughts"},{"location":"mind-machine-docs/dev/","text":"Developer Notes \u00b6 Makefiles \u00b6 The Makefile in each mind machine repository provides rules to help you perform common tasks. There are three types of tasks: Makefile rules run after the first clone of a brand-new mind machine repo Makefile rules run after a fresh clone of an existing mind machine repo Makefile rules for testing, creating, deploying The Prime Number Version System \u00b6 Crash course in the prime number version system: Branches: master - contains stable, tagged releases. Each release is a unique prime number, occurring in ascending order. dev - development branch. All work happens here. feature - feature branch. Feature branches are created from the dev branch, and commits from these feature branches are merged back into the dev branch before they are ultimately added to a mind machine release. release/vP - branch preparing a release of version P. Changes on release branches are almost always synchronized with the development branch. Workflow: Start from a stable version on master Create branch dev from master (or pull from master into dev if it already exists) Create branch feature from dev (feature branch contains all work on a particular feature) When ready, merge changes from feature into dev Once dev branch is ready for a release, create a release candidate branch release/vP Testing \u00b6 Using examples to test interactivity Tests are mainly smoke tests For complicated example, see bear/python-twitter on Github Release Process \u00b6 See branching workflow above. Checklist: Test examples Test create Docker container Test documentation (but documentation can be/should be separate) Update submodules Mainly code When ready: Pypi upload How to set up: Dockerhub (update with new versions) Docker \u00b6 Developer considerations for docker container","title":"Developer Notes"},{"location":"mind-machine-docs/dev/#developer-notes","text":"","title":"Developer Notes"},{"location":"mind-machine-docs/dev/#makefiles","text":"The Makefile in each mind machine repository provides rules to help you perform common tasks. There are three types of tasks: Makefile rules run after the first clone of a brand-new mind machine repo Makefile rules run after a fresh clone of an existing mind machine repo Makefile rules for testing, creating, deploying","title":"Makefiles"},{"location":"mind-machine-docs/dev/#the-prime-number-version-system","text":"Crash course in the prime number version system: Branches: master - contains stable, tagged releases. Each release is a unique prime number, occurring in ascending order. dev - development branch. All work happens here. feature - feature branch. Feature branches are created from the dev branch, and commits from these feature branches are merged back into the dev branch before they are ultimately added to a mind machine release. release/vP - branch preparing a release of version P. Changes on release branches are almost always synchronized with the development branch. Workflow: Start from a stable version on master Create branch dev from master (or pull from master into dev if it already exists) Create branch feature from dev (feature branch contains all work on a particular feature) When ready, merge changes from feature into dev Once dev branch is ready for a release, create a release candidate branch release/vP","title":"The Prime Number Version System"},{"location":"mind-machine-docs/dev/#testing","text":"Using examples to test interactivity Tests are mainly smoke tests For complicated example, see bear/python-twitter on Github","title":"Testing"},{"location":"mind-machine-docs/dev/#release-process","text":"See branching workflow above. Checklist: Test examples Test create Docker container Test documentation (but documentation can be/should be separate) Update submodules Mainly code When ready: Pypi upload How to set up: Dockerhub (update with new versions)","title":"Release Process"},{"location":"mind-machine-docs/dev/#docker","text":"Developer considerations for docker container","title":"Docker"},{"location":"mind-machine-docs/keymaker/","text":"The Keymaker \u00b6 You can definitely trust this keymaker. The Keymaker is the object that is used to authenticate with the third party service and generate the bot keys the application needs to do things on behalf of a user account. This document provides a high-level overview of the Keymaker. Using the Keymaker \u00b6 If you don't care about all of this business and just want to know how to use the keymaker, see the boring mind machine documentation . Specifically, see coverage of the BoringOAuthKeymaker class, along with the service-specific Github Keymaker , Google Keymaker , and Twitter Keymaker classes. Background: The Three-Legged OAuth Process \u00b6 In theory, not all Keymakers must do OAuth, but in practice, all Keymakers do OAuth . The Keymaker carries out a one-time authorization step that needs to be done once for each Sheep = bot = account. The Keymaker will be given a set of \"items\" (more on this in a moment), with one item = one Sheep = one bot = one account, etc. The Keymaker iterates through each item and performs the three-legged OAuth process. Here's a summary of the process: The three legs are: the user (the bot account), the third party service (Github/Google/Twitter/other), and the consumer (your mind machine app - specifically, the Keymaker component) The Keymaker will initiate the process by requesting an OAuth URL from the third party (this is how an app asks a user for permission to access their account) Third party will return an OAuth URL to the Keymaker, which will pass it to the user The user will open the URL in their browser, and sign in using a bot account Third party will verify the credentials of the user, and create a temporary token This token is returned to the API application (via callback URL/other mechanism) API application sends the token to the third party, which verifies the token matches Third party gives the API application a new OAuth token. This is the magic token that allows the OAuth application to do things with the bot account. Why the song and dance? The three-legged authentication process is intended to allow API applications to verify a user's identity (i.e., yes this user actually granted permission for the API application to control their account) without having to handle sensitive data like a user's hashed password. It also keeps the third party in control of the process. Keymaker Credentials \u00b6 Keymaker Input: API Keys \u00b6 There are two pieces of information that are required to do things as your API application (independent of any bot accounts): API application key API application secret key These are the two pieces of information that are required to prove to the third party service that you are the actual owner of your application. Each service stores these pieces of information in different ways, and calls them by different names. For example: Client key/client secret key Consumer token/consumer token secret API token/API secret token etc... The boring mind machine library provides a base OAuth Keymaker class called BoringOAuthKeymaker. This class implements the OAuth process in a generic way. The details specific to the third party service are then implemented in child classes (e.g., GithubKeymaker). Keymaker Output: OAuth Keys \u00b6 In general, the Keymaker creates a set of bot account keys corresponding to a set of items. Once the Keymaker and the user go through the three-legged authentication process for one bot account, the Keymaker will create a JSON file with the bot key so that it can be used again in the future. The bot key contains both the API keys for the application, and the OAuth keys for the bot account.","title":"Keymaker"},{"location":"mind-machine-docs/keymaker/#the-keymaker","text":"You can definitely trust this keymaker. The Keymaker is the object that is used to authenticate with the third party service and generate the bot keys the application needs to do things on behalf of a user account. This document provides a high-level overview of the Keymaker.","title":"The Keymaker"},{"location":"mind-machine-docs/keymaker/#using-the-keymaker","text":"If you don't care about all of this business and just want to know how to use the keymaker, see the boring mind machine documentation . Specifically, see coverage of the BoringOAuthKeymaker class, along with the service-specific Github Keymaker , Google Keymaker , and Twitter Keymaker classes.","title":"Using the Keymaker"},{"location":"mind-machine-docs/keymaker/#background-the-three-legged-oauth-process","text":"In theory, not all Keymakers must do OAuth, but in practice, all Keymakers do OAuth . The Keymaker carries out a one-time authorization step that needs to be done once for each Sheep = bot = account. The Keymaker will be given a set of \"items\" (more on this in a moment), with one item = one Sheep = one bot = one account, etc. The Keymaker iterates through each item and performs the three-legged OAuth process. Here's a summary of the process: The three legs are: the user (the bot account), the third party service (Github/Google/Twitter/other), and the consumer (your mind machine app - specifically, the Keymaker component) The Keymaker will initiate the process by requesting an OAuth URL from the third party (this is how an app asks a user for permission to access their account) Third party will return an OAuth URL to the Keymaker, which will pass it to the user The user will open the URL in their browser, and sign in using a bot account Third party will verify the credentials of the user, and create a temporary token This token is returned to the API application (via callback URL/other mechanism) API application sends the token to the third party, which verifies the token matches Third party gives the API application a new OAuth token. This is the magic token that allows the OAuth application to do things with the bot account. Why the song and dance? The three-legged authentication process is intended to allow API applications to verify a user's identity (i.e., yes this user actually granted permission for the API application to control their account) without having to handle sensitive data like a user's hashed password. It also keeps the third party in control of the process.","title":"Background: The Three-Legged OAuth Process"},{"location":"mind-machine-docs/keymaker/#keymaker-credentials","text":"","title":"Keymaker Credentials"},{"location":"mind-machine-docs/keymaker/#keymaker-input-api-keys","text":"There are two pieces of information that are required to do things as your API application (independent of any bot accounts): API application key API application secret key These are the two pieces of information that are required to prove to the third party service that you are the actual owner of your application. Each service stores these pieces of information in different ways, and calls them by different names. For example: Client key/client secret key Consumer token/consumer token secret API token/API secret token etc... The boring mind machine library provides a base OAuth Keymaker class called BoringOAuthKeymaker. This class implements the OAuth process in a generic way. The details specific to the third party service are then implemented in child classes (e.g., GithubKeymaker).","title":"Keymaker Input: API Keys"},{"location":"mind-machine-docs/keymaker/#keymaker-output-oauth-keys","text":"In general, the Keymaker creates a set of bot account keys corresponding to a set of items. Once the Keymaker and the user go through the three-legged authentication process for one bot account, the Keymaker will create a JSON file with the bot key so that it can be used again in the future. The bot key contains both the API keys for the application, and the OAuth keys for the bot account.","title":"Keymaker Output: OAuth Keys"},{"location":"mind-machine-docs/sheep/","text":"The Sheep \u00b6 The rainbow mind machine sheep. The Sheep is the component of the bot flock that actually performs the actions using the bot accounts. The Shepherd will instruct each Sheep to start performing an action - either in parallel (if it is a \"forever\" action like tweeting) or in serial (if it is a \"one-time\" action, like changing the bot user's profile). Each Sheep uses a bot key (created by the Keymaker and loaded by the Shepherd) to create an API instance in the constructor. Each Sheep then uses that API instance to perform actions. The BoringSheep base class in boring mind machine defines a generic dispatcher method (which turns strings into function calls) to allow Shepherds to call particular actions for each Sheep. Defining Actions \u00b6 To define an action, define a method for that action. (For example, to define a tweet action, make a tweet() method in the Sheep class you are using.) To control how the action works and introduce variation, you can pass extra parameters (in the form of keyword arguments) to the action method, and the Shepherd will pass those along to the Sheep. The general pattern this follows is: set up or point to an API endpoint create or use the API client object to call the API endpoint process the results","title":"Sheep"},{"location":"mind-machine-docs/sheep/#the-sheep","text":"The rainbow mind machine sheep. The Sheep is the component of the bot flock that actually performs the actions using the bot accounts. The Shepherd will instruct each Sheep to start performing an action - either in parallel (if it is a \"forever\" action like tweeting) or in serial (if it is a \"one-time\" action, like changing the bot user's profile). Each Sheep uses a bot key (created by the Keymaker and loaded by the Shepherd) to create an API instance in the constructor. Each Sheep then uses that API instance to perform actions. The BoringSheep base class in boring mind machine defines a generic dispatcher method (which turns strings into function calls) to allow Shepherds to call particular actions for each Sheep.","title":"The Sheep"},{"location":"mind-machine-docs/sheep/#defining-actions","text":"To define an action, define a method for that action. (For example, to define a tweet action, make a tweet() method in the Sheep class you are using.) To control how the action works and introduce variation, you can pass extra parameters (in the form of keyword arguments) to the action method, and the Shepherd will pass those along to the Sheep. The general pattern this follows is: set up or point to an API endpoint create or use the API client object to call the API endpoint process the results","title":"Defining Actions"},{"location":"mind-machine-docs/shepherd/","text":"The Shepherd \u00b6 The shepherd's ( pasteur ) power manifests itself, therefore, in a duty, a task to be undertaken, so that - and I think this is also an important characteristic of pastoral power - the form it takes is not first of all the striking display of strength and superiority. Pastoral power initially manifests itself in its zeal, devotion, and endless application. What is the shepherd ( berger )? Is (s)he someone whose strength strikes people's eyes, like the sovereigns or gods, like the Greek gods, who essentially appear in their splendor? Not at all. The shepherd is someone who keeps watch. (S)he \"keeps watch\" in the sense, of course, of keeping an eye out for possible evils, but above all in the sense of vigilance with regard to any possible misfortune. Michel Foucault, Security, Territory, Population: Lectures at the Coll\u00e9ge de France (1977-1978) The rainbow mind machine shepherd. what is the Shepherd? \u00b6 The Shepherd is a very simple object: it is basically a data container for storing Sheep. when does the Shepherd come in? \u00b6 The first thing a bot flock needs is a set of keys. That's what the Keymaker is for. Once the bot flock keys have been created with the Keymaker, the bot flock is started. To do that, the Shepherd initializes each Sheep with a corresponding JSON key file (created by the Keymaker). how does the Shepherd tend to the Sheep? \u00b6 In general, the Shepherd is a free-range parent, and lets the Sheep go off and do their own thing. Note however, that in the spirit of extensibility, you can extend the Shepherd and Sheep classes to change the nature of your bot flock. (See next section.) when and how do you extend the Shepherd? \u00b6 The Shepherd class determines how much coordination happens among different Sheep in the flock and between the flock and the outside world (the Internet). Some simple examples: webhook bot flock \u00b6 As an example of a bot flock that requires tighter integration between the Shepherd and the Sheep, imagine you want to create a bot fock where the bots can be controlled with webhooks. You would need the Shepherd to act as a central dispatcher and process incoming webhooks to determine which webhook payloads to pass on to which Sheep. But the Sheep also need to be modified to listen for instructions from the Shepherd. To modify the Shepherd class, we would add a method that listens for incoming webhooks, and a method or methods implementing logic about which payloads to pass along to which Sheep (or to call the appropriate functions when webhooks trigger flock-wide actions). To modify the Sheep class, we would add a listen() method that would run forever - ideally in parallel with other run-forever methods. two bots per key flock \u00b6 Suppose we wanted to build an argument bot flock. This bot flock would consist of pairs of Sheep that use Queneau generation to create dialogue, and that argue back and forth forever with each other. This bot flock modifies the way that our Sheep coordinate with each other, which is an indication we should change the Shepherd class. The Sheep bots we will use will work identically to a normal Queneau Sheep bot. Each bot generates dialogue from a single speaker, and tweets it in response to another bot tweeting. While we could extend the Sheep class to control the dialogue, it would be easier to use the inner/outer loop structure that the QueneauSheep class already has. That way, the Sheep do not require any extending. The Shepherd class needs to be modified by changing the way it instantiates bots from keys. Instead of creating one bot per key, it should create two bots per keys. (Note that the user will need to provide relevant details in the key or config dictionaries. For example, name and handle of both bot sides, inner/outer loop timing, etc.) The -setup_keys() method will not change, because we want to maintain the consistency of one key file corresponding to one bot corresponding to one Twitter account. The _setup_sheep() method would be modified from its current arrangement (pseudocode): current _setup_sheep() method: for json in list-of-all-json-files: create new sheep from json add new sheep to flock to something more like (pseudocode): new _setup_sheep() method: for (bot1, bot2) in list-of-all-bot-pairs: get key1 from keys create bot1 from key1 get key2 from keys create bot2 from key2 link bot1 and bot2 add bot1 and bot2 to flock In this case, we want to have two Queneau Sheep that work almost exactly the same as normal Queneau Sheep, with perhaps a slight modification to make sure that each bot generates dialogue from a single speaker corresponding to their party in the argument.","title":"Shepherd"},{"location":"mind-machine-docs/shepherd/#the-shepherd","text":"The shepherd's ( pasteur ) power manifests itself, therefore, in a duty, a task to be undertaken, so that - and I think this is also an important characteristic of pastoral power - the form it takes is not first of all the striking display of strength and superiority. Pastoral power initially manifests itself in its zeal, devotion, and endless application. What is the shepherd ( berger )? Is (s)he someone whose strength strikes people's eyes, like the sovereigns or gods, like the Greek gods, who essentially appear in their splendor? Not at all. The shepherd is someone who keeps watch. (S)he \"keeps watch\" in the sense, of course, of keeping an eye out for possible evils, but above all in the sense of vigilance with regard to any possible misfortune. Michel Foucault, Security, Territory, Population: Lectures at the Coll\u00e9ge de France (1977-1978) The rainbow mind machine shepherd.","title":"The Shepherd"},{"location":"mind-machine-docs/shepherd/#what-is-the-shepherd","text":"The Shepherd is a very simple object: it is basically a data container for storing Sheep.","title":"what is the Shepherd?"},{"location":"mind-machine-docs/shepherd/#when-does-the-shepherd-come-in","text":"The first thing a bot flock needs is a set of keys. That's what the Keymaker is for. Once the bot flock keys have been created with the Keymaker, the bot flock is started. To do that, the Shepherd initializes each Sheep with a corresponding JSON key file (created by the Keymaker).","title":"when does the Shepherd come in?"},{"location":"mind-machine-docs/shepherd/#how-does-the-shepherd-tend-to-the-sheep","text":"In general, the Shepherd is a free-range parent, and lets the Sheep go off and do their own thing. Note however, that in the spirit of extensibility, you can extend the Shepherd and Sheep classes to change the nature of your bot flock. (See next section.)","title":"how does the Shepherd tend to the Sheep?"},{"location":"mind-machine-docs/shepherd/#when-and-how-do-you-extend-the-shepherd","text":"The Shepherd class determines how much coordination happens among different Sheep in the flock and between the flock and the outside world (the Internet). Some simple examples:","title":"when and how do you extend the Shepherd?"},{"location":"mind-machine-docs/shepherd/#webhook-bot-flock","text":"As an example of a bot flock that requires tighter integration between the Shepherd and the Sheep, imagine you want to create a bot fock where the bots can be controlled with webhooks. You would need the Shepherd to act as a central dispatcher and process incoming webhooks to determine which webhook payloads to pass on to which Sheep. But the Sheep also need to be modified to listen for instructions from the Shepherd. To modify the Shepherd class, we would add a method that listens for incoming webhooks, and a method or methods implementing logic about which payloads to pass along to which Sheep (or to call the appropriate functions when webhooks trigger flock-wide actions). To modify the Sheep class, we would add a listen() method that would run forever - ideally in parallel with other run-forever methods.","title":"webhook bot flock"},{"location":"mind-machine-docs/shepherd/#two-bots-per-key-flock","text":"Suppose we wanted to build an argument bot flock. This bot flock would consist of pairs of Sheep that use Queneau generation to create dialogue, and that argue back and forth forever with each other. This bot flock modifies the way that our Sheep coordinate with each other, which is an indication we should change the Shepherd class. The Sheep bots we will use will work identically to a normal Queneau Sheep bot. Each bot generates dialogue from a single speaker, and tweets it in response to another bot tweeting. While we could extend the Sheep class to control the dialogue, it would be easier to use the inner/outer loop structure that the QueneauSheep class already has. That way, the Sheep do not require any extending. The Shepherd class needs to be modified by changing the way it instantiates bots from keys. Instead of creating one bot per key, it should create two bots per keys. (Note that the user will need to provide relevant details in the key or config dictionaries. For example, name and handle of both bot sides, inner/outer loop timing, etc.) The -setup_keys() method will not change, because we want to maintain the consistency of one key file corresponding to one bot corresponding to one Twitter account. The _setup_sheep() method would be modified from its current arrangement (pseudocode): current _setup_sheep() method: for json in list-of-all-json-files: create new sheep from json add new sheep to flock to something more like (pseudocode): new _setup_sheep() method: for (bot1, bot2) in list-of-all-bot-pairs: get key1 from keys create bot1 from key1 get key2 from keys create bot2 from key2 link bot1 and bot2 add bot1 and bot2 to flock In this case, we want to have two Queneau Sheep that work almost exactly the same as normal Queneau Sheep, with perhaps a slight modification to make sure that each bot generates dialogue from a single speaker corresponding to their party in the argument.","title":"two bots per key flock"}]}