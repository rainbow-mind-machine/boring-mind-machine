{
    "docs": [
        {
            "location": "/",
            "text": "boring-mind-machine\n\u00b6\n\n\nboring mind machine\n is a set of boring base classes for building awesome bot flocks.\n\n\nOther mind machine libraries utilize the \nboring mind machine\n library's\nclasses as a starting point for implementing bot flocks.\n\n\nLinks\n\u00b6\n\n\nboring mind machine (bmm) links:\n\n\n\n\nbmm source code on Github: \nhttps://github.com/rainbow-mind-machine/boring-mind-machine\n\n\nbmm documentation: \nhttps://pages.charlesreid1.com/boring-mind-machine/\n\n\nrainbow mind machine organization on Github: \nhttps://github.com/rainbow-mind-machine\n\n\n\n\nPages\n\u00b6\n\n\nAbout the Mind Machine Framework\n - general\ninformation about the mind machine framework (how does it work? what does it\nlook like?)\n\n\nAbout Boring Mind Machine\n - about the boring mind machine library\n(what is it? what does it do?)\n\n\nInstalling\n - installation instructions (how do I install bmm?)\n\n\nQuick Start\n - quick start instructions for getting started\nwith boring mind machine base classes (how do I run bmm?)\n\n\nDocumentation for components implemented in boring mind machine:\n\n\n\n\nKeymakers:\n\n\nBoringKeymaker\n\n\nBoringOAuthKeymaker\n\n\nGithubKeymaker\n\n\nGoogleKeymaker\n\n\nTwitterKeymaker\n\n\n\n\n\n\nBoringShepherd\n\n\nBoringSheep\n\n\n\n\nFuture Work and Ideas\n (what's next for boring mind machine?)\n\n\nCredits\n\n\nContributing\n\n\nDeveloper Notes\n - notes on processes for developers\n(how do I run tests, update packages/images, build documentation, etc.?)",
            "title": "Home"
        },
        {
            "location": "/#boring-mind-machine",
            "text": "boring mind machine  is a set of boring base classes for building awesome bot flocks.  Other mind machine libraries utilize the  boring mind machine  library's\nclasses as a starting point for implementing bot flocks.",
            "title": "boring-mind-machine"
        },
        {
            "location": "/#links",
            "text": "boring mind machine (bmm) links:   bmm source code on Github:  https://github.com/rainbow-mind-machine/boring-mind-machine  bmm documentation:  https://pages.charlesreid1.com/boring-mind-machine/  rainbow mind machine organization on Github:  https://github.com/rainbow-mind-machine",
            "title": "Links"
        },
        {
            "location": "/#pages",
            "text": "About the Mind Machine Framework  - general\ninformation about the mind machine framework (how does it work? what does it\nlook like?)  About Boring Mind Machine  - about the boring mind machine library\n(what is it? what does it do?)  Installing  - installation instructions (how do I install bmm?)  Quick Start  - quick start instructions for getting started\nwith boring mind machine base classes (how do I run bmm?)  Documentation for components implemented in boring mind machine:   Keymakers:  BoringKeymaker  BoringOAuthKeymaker  GithubKeymaker  GoogleKeymaker  TwitterKeymaker    BoringShepherd  BoringSheep   Future Work and Ideas  (what's next for boring mind machine?)  Credits  Contributing  Developer Notes  - notes on processes for developers\n(how do I run tests, update packages/images, build documentation, etc.?)",
            "title": "Pages"
        },
        {
            "location": "/mind-machine-docs/about/",
            "text": "Mind Machine Framework\n\u00b6\n\n\nThe mind machine framework is designed to be a\n\nsimple, extensible framework\n for developing\nbots.\n\n\nHow is it extensible?\n\u00b6\n\n\nThe concept of \"extensible\" refers specifically to the use\nof inheritance and extended classes. \n\n\nThe mind machine philosophy is to keep things as simple\nas possible, and add functionality in an incremental way\nto keep things easy to understand.\n\n\nUsing inheritance and extending base classes allows us to\nbuild up simple functionality into more complicated bots.\n\n\nHow is it simple?\n\u00b6\n\n\nThe mind machine concept is simple because there are only three\ncomponents:\n\n\n\n\nKeymaker\n\n\nSheep\n\n\nShepherd\n\n\n\n\nHow is it POOP-y?\n\u00b6\n\n\nThe mind machine libraries are a great illustration of\nPython Object-Oriented Programming (POOP) in action.\nThese are very POOP-y libraries, in that they use\nclasses to combine minimal functionality into classes.\n\n\nDeep Thoughts\n\u00b6\n\n\nFoucault\n\n\nMotivations\n\n\nNaming things",
            "title": "About Mind Machine Framework"
        },
        {
            "location": "/mind-machine-docs/about/#mind-machine-framework",
            "text": "The mind machine framework is designed to be a simple, extensible framework  for developing\nbots.",
            "title": "Mind Machine Framework"
        },
        {
            "location": "/mind-machine-docs/about/#how-is-it-extensible",
            "text": "The concept of \"extensible\" refers specifically to the use\nof inheritance and extended classes.   The mind machine philosophy is to keep things as simple\nas possible, and add functionality in an incremental way\nto keep things easy to understand.  Using inheritance and extending base classes allows us to\nbuild up simple functionality into more complicated bots.",
            "title": "How is it extensible?"
        },
        {
            "location": "/mind-machine-docs/about/#how-is-it-simple",
            "text": "The mind machine concept is simple because there are only three\ncomponents:   Keymaker  Sheep  Shepherd",
            "title": "How is it simple?"
        },
        {
            "location": "/mind-machine-docs/about/#how-is-it-poop-y",
            "text": "The mind machine libraries are a great illustration of\nPython Object-Oriented Programming (POOP) in action.\nThese are very POOP-y libraries, in that they use\nclasses to combine minimal functionality into classes.",
            "title": "How is it POOP-y?"
        },
        {
            "location": "/mind-machine-docs/about/#deep-thoughts",
            "text": "Foucault  Motivations  Naming things",
            "title": "Deep Thoughts"
        },
        {
            "location": "/mind-machine-docs/keymaker/",
            "text": "The Keymaker\n\u00b6\n\n\n\n\nYou can definitely trust this keymaker.\n\n\nThe Keymaker is the object that is used to authenticate with the third party\nservice and generate the bot keys the application needs to do things on behalf\nof a user account.\n\n\nThis document provides a high-level overview of the Keymaker.\n\n\nThe Three-Legged OAuth Process\n\u00b6\n\n\nIn theory, not all Keymakers must do OAuth, but in practice,\n\nall Keymakers do OAuth\n.\n\n\nThe Keymaker carries out a one-time authorization step that needs to \nbe done once for each Sheep = bot = account.\n\n\nThe Keymaker will be given a set of \"items\" (more on this in a moment), with one\nitem = one Sheep = one bot = one account, etc.  The Keymaker iterates through\neach item and performs the three-legged OAuth process.\n\n\nHere's a summary of the process:\n\n\n\n\nThe three legs are: the user (the bot account), the third party service (Github/Google/Twitter/other), and the consumer \n    (your mind machine app - specifically, the Keymaker component)\n\n\nThe Keymaker will initiate the process by requesting an OAuth URL from the third party\n    (this is how an app asks a user for permission to access their account)\n\n\nThird party will return an OAuth URL to the Keymaker, which will pass it to the user\n\n\nThe user will open the URL in their browser, and sign in using a bot account\n\n\nThird party will verify the credentials of the user, and create a temporary token\n\n\nThis token is returned to the API application (via callback URL/other mechanism)\n\n\nAPI application sends the token to the third party, which verifies the token matches\n\n\nThird party gives the API application a new OAuth token. This is the magic token\n    that allows the OAuth application to do things with the bot account.\n\n\n\n\nWhy the song and dance? The three-legged authentication process is intended to \nallow API applications to verify a user's identity (i.e., yes this user \nactually\n granted\npermission for the API application to control their account) without having to handle\nsensitive data like a user's hashed password. It also keeps the third party in\ncontrol of the process.\n\n\nKeymaker Credentials\n\u00b6\n\n\nKeymaker Input: API Keys\n\u00b6\n\n\nThere are two pieces of information that are required\nto do things as your API application (independent of any\nbot accounts):\n\n\n\n\nAPI application key\n\n\nAPI application secret key\n\n\n\n\nThese are the two pieces of information that are required to prove\nto the third party service that you are the actual owner of your\napplication.\n\n\nEach service stores these pieces of information in different ways,\nand calls them by different names. For example:\n\n\n\n\nClient key/client secret key\n\n\nConsumer token/consumer token secret\n\n\nAPI token/API secret token\n\n\netc...\n\n\n\n\nThe \nboring mind machine\n\nlibrary provides a base OAuth Keymaker class\ncalled BoringOAuthKeymaker. This class implements\nthe OAuth process in a generic way. The details\nspecific to the third party service are then implemented\nin child classes (e.g., GithubKeymaker).\n\n\nKeymaker Output: OAuth Keys\n\u00b6\n\n\nIn general, the Keymaker creates a set of bot account keys\ncorresponding to a set of items.\n\n\nOnce the Keymaker and the user go through the three-legged\nauthentication process for one bot account, the Keymaker\nwill create a JSON file with the bot key so that it can\nbe used again in the future.\n\n\nThe bot key contains both the API keys for the application,\nand the OAuth keys for the bot account.\n\n\nUsing the Keymaker\n\u00b6\n\n\nFor details about how to create keys using the\nOAuth Keymaker base class, see the \n\nboring mind machine documentation\n.\n\n\nTo extend the Keymaker class, you should override\nthe \nmake_keys()\n method to create keys in whatever\nmanner you wish.",
            "title": "Keymaker"
        },
        {
            "location": "/mind-machine-docs/keymaker/#the-keymaker",
            "text": "You can definitely trust this keymaker.  The Keymaker is the object that is used to authenticate with the third party\nservice and generate the bot keys the application needs to do things on behalf\nof a user account.  This document provides a high-level overview of the Keymaker.",
            "title": "The Keymaker"
        },
        {
            "location": "/mind-machine-docs/keymaker/#the-three-legged-oauth-process",
            "text": "In theory, not all Keymakers must do OAuth, but in practice, all Keymakers do OAuth .  The Keymaker carries out a one-time authorization step that needs to \nbe done once for each Sheep = bot = account.  The Keymaker will be given a set of \"items\" (more on this in a moment), with one\nitem = one Sheep = one bot = one account, etc.  The Keymaker iterates through\neach item and performs the three-legged OAuth process.  Here's a summary of the process:   The three legs are: the user (the bot account), the third party service (Github/Google/Twitter/other), and the consumer \n    (your mind machine app - specifically, the Keymaker component)  The Keymaker will initiate the process by requesting an OAuth URL from the third party\n    (this is how an app asks a user for permission to access their account)  Third party will return an OAuth URL to the Keymaker, which will pass it to the user  The user will open the URL in their browser, and sign in using a bot account  Third party will verify the credentials of the user, and create a temporary token  This token is returned to the API application (via callback URL/other mechanism)  API application sends the token to the third party, which verifies the token matches  Third party gives the API application a new OAuth token. This is the magic token\n    that allows the OAuth application to do things with the bot account.   Why the song and dance? The three-legged authentication process is intended to \nallow API applications to verify a user's identity (i.e., yes this user  actually  granted\npermission for the API application to control their account) without having to handle\nsensitive data like a user's hashed password. It also keeps the third party in\ncontrol of the process.",
            "title": "The Three-Legged OAuth Process"
        },
        {
            "location": "/mind-machine-docs/keymaker/#keymaker-credentials",
            "text": "",
            "title": "Keymaker Credentials"
        },
        {
            "location": "/mind-machine-docs/keymaker/#keymaker-input-api-keys",
            "text": "There are two pieces of information that are required\nto do things as your API application (independent of any\nbot accounts):   API application key  API application secret key   These are the two pieces of information that are required to prove\nto the third party service that you are the actual owner of your\napplication.  Each service stores these pieces of information in different ways,\nand calls them by different names. For example:   Client key/client secret key  Consumer token/consumer token secret  API token/API secret token  etc...   The  boring mind machine \nlibrary provides a base OAuth Keymaker class\ncalled BoringOAuthKeymaker. This class implements\nthe OAuth process in a generic way. The details\nspecific to the third party service are then implemented\nin child classes (e.g., GithubKeymaker).",
            "title": "Keymaker Input: API Keys"
        },
        {
            "location": "/mind-machine-docs/keymaker/#keymaker-output-oauth-keys",
            "text": "In general, the Keymaker creates a set of bot account keys\ncorresponding to a set of items.  Once the Keymaker and the user go through the three-legged\nauthentication process for one bot account, the Keymaker\nwill create a JSON file with the bot key so that it can\nbe used again in the future.  The bot key contains both the API keys for the application,\nand the OAuth keys for the bot account.",
            "title": "Keymaker Output: OAuth Keys"
        },
        {
            "location": "/mind-machine-docs/keymaker/#using-the-keymaker",
            "text": "For details about how to create keys using the\nOAuth Keymaker base class, see the  boring mind machine documentation .  To extend the Keymaker class, you should override\nthe  make_keys()  method to create keys in whatever\nmanner you wish.",
            "title": "Using the Keymaker"
        },
        {
            "location": "/mind-machine-docs/shepherd/",
            "text": "The Shepherd\n\u00b6\n\n\n(TODO: Add high level shepherd summary)",
            "title": "Shepherd"
        },
        {
            "location": "/mind-machine-docs/shepherd/#the-shepherd",
            "text": "(TODO: Add high level shepherd summary)",
            "title": "The Shepherd"
        },
        {
            "location": "/mind-machine-docs/sheep/",
            "text": "The Sheep\n\u00b6\n\n\n(TODO: add high level sheep summary)",
            "title": "Sheep"
        },
        {
            "location": "/mind-machine-docs/sheep/#the-sheep",
            "text": "(TODO: add high level sheep summary)",
            "title": "The Sheep"
        },
        {
            "location": "/about/",
            "text": "About Boring Mind Machine\n\u00b6\n\n\nThe main job of \nboring mind machine\n is to take care of the boring stuff.\nSpecifically, (1) provide base classes for all other mind machines, and\n(2) provide Keymakers for different services (Github, Google, Twitter, etc.).",
            "title": "About bmm"
        },
        {
            "location": "/about/#about-boring-mind-machine",
            "text": "The main job of  boring mind machine  is to take care of the boring stuff.\nSpecifically, (1) provide base classes for all other mind machines, and\n(2) provide Keymakers for different services (Github, Google, Twitter, etc.).",
            "title": "About Boring Mind Machine"
        },
        {
            "location": "/installing/",
            "text": "Installing\n\u00b6\n\n\n(TODO: add installation steps)",
            "title": "Installing bmm"
        },
        {
            "location": "/installing/#installing",
            "text": "(TODO: add installation steps)",
            "title": "Installing"
        },
        {
            "location": "/quickstart/",
            "text": "Quick Start with Boring Mind Machine\n\u00b6\n\n\nLet's run through some of the tests.\n\n\nKeymakers\n\u00b6",
            "title": "Quick Start"
        },
        {
            "location": "/quickstart/#quick-start-with-boring-mind-machine",
            "text": "Let's run through some of the tests.",
            "title": "Quick Start with Boring Mind Machine"
        },
        {
            "location": "/quickstart/#keymakers",
            "text": "",
            "title": "Keymakers"
        },
        {
            "location": "/boring_keymaker/",
            "text": "Boring Keymaker and Boring OAuth Keymaker\n\u00b6\n\n\nThere are two base Keymaker classes implemented by \nboring mind machine; they are \nBoringKeymaker\n and\n\nBoringOAuthKeymaker\n.\n\n\nTechnically a Keymaker can inherit from BoringKeymaker\nand use any authentication method, but in practice all\nKeymakers are OAuth Keymakers.\n\n\n(TODO: add list of important class methods)\n(TODO: how is oauth keymaker extended - what method)",
            "title": "Boring Keymaker"
        },
        {
            "location": "/boring_keymaker/#boring-keymaker-and-boring-oauth-keymaker",
            "text": "There are two base Keymaker classes implemented by \nboring mind machine; they are  BoringKeymaker  and BoringOAuthKeymaker .  Technically a Keymaker can inherit from BoringKeymaker\nand use any authentication method, but in practice all\nKeymakers are OAuth Keymakers.  (TODO: add list of important class methods)\n(TODO: how is oauth keymaker extended - what method)",
            "title": "Boring Keymaker and Boring OAuth Keymaker"
        },
        {
            "location": "/boring_keymaker/",
            "text": "Boring Keymaker and Boring OAuth Keymaker\n\u00b6\n\n\nThere are two base Keymaker classes implemented by \nboring mind machine; they are \nBoringKeymaker\n and\n\nBoringOAuthKeymaker\n.\n\n\nTechnically a Keymaker can inherit from BoringKeymaker\nand use any authentication method, but in practice all\nKeymakers are OAuth Keymakers.\n\n\n(TODO: add list of important class methods)\n(TODO: how is oauth keymaker extended - what method)",
            "title": "Boring OAuth Keymaker"
        },
        {
            "location": "/boring_keymaker/#boring-keymaker-and-boring-oauth-keymaker",
            "text": "There are two base Keymaker classes implemented by \nboring mind machine; they are  BoringKeymaker  and BoringOAuthKeymaker .  Technically a Keymaker can inherit from BoringKeymaker\nand use any authentication method, but in practice all\nKeymakers are OAuth Keymakers.  (TODO: add list of important class methods)\n(TODO: how is oauth keymaker extended - what method)",
            "title": "Boring Keymaker and Boring OAuth Keymaker"
        },
        {
            "location": "/keymaker_github/",
            "text": "Github Keymaker Example\n\u00b6\n\n\nSee \nboring-mind-machine/examples/github\n.\n\n\nAn example of creating a Github OAuth keymaker.\n\n\nCreating a Github App\n\u00b6\n\n\nThe brief summary of what we cover here:\n\n\nWe need to create an application (something that will consume the API\nendpoints), and we need to grant the application access to at least one \nGithub account.\n\n\nSet Up API and Create App\n\u00b6\n\n\nTo create an OAuth app as a user, see \n\nthese detailed instructions\n\nfrom Github.\n\n\nWhen you create your OAuth app, the one crucial\npiece of information is the callback URL. This is\nwhere the magic token is sent once the user logs in\nwith their Github account.\n\n\nThe Github Keymaker runs a server on localhost port 8000,\nso \nthe callback URL for your OAuth application should be \nset to \nhttp://localhost:8000\n.\n\n\nGetting App Credentials\n\u00b6\n\n\nOnce you have created your application, the application's\ndescription page will contain the client ID and client secret\nneeded to use this application to run mind machine bots\nusing Github.\n\n\nEnd Result\n\u00b6\n\n\nIn the end you should have a pair of API keys (a client ID and\na client secret), which you will pass to the keymaker using\none of the three methods provided (via a dictionary, a JSON\nfile, or environment variables).\n\n\nTo run the Github Keymaker example, you need to pass the API\nkeys to the keymaker using one of three methods:\n\n\n\n\nUsing a dictionary\n\n\nUsing a JSON file\n\n\nUsing environment variables\n\n\n\n\nTo use the latter option, you can run the Github Keymaker program\nlike this:\n\n\n$ CLIENT_ID=\"...\" CLIENT_SECRET=\"...\" python github_auth.py\n\n\n\n\n\nAuthorizing\n\u00b6\n\n\nTo run this, you will need your client ID and client secret.\nThese can be found by logging in as the user that created the\nOAuth application you will be using, or that is an admin on the\norganization that owns the OAuth account. Go to the settings page\nand find the OAuth Applications listing on the left side. The\nOAuth application page will list the client ID and client secret\nat the top of the page.\n\n\nOnce you have them, set the \nCLIENT_ID\n and \nCLIENT_SECRET\n environment\nvariables when you run the program, like this:\n\n\n$ CLIENT_ID=\"...\" \\\n  CLIENT_SECRET=\"...\" \\\n  python github_auth.py\n\n\n\n\n\nThis will create an authorization link, which you can log in to with\nany Github account. The Keymaker will create bot keys in \nkeys/\n,\nand will then clean up and remove the \nkeys/\n directory.",
            "title": "Github Keymaker"
        },
        {
            "location": "/keymaker_github/#github-keymaker-example",
            "text": "See  boring-mind-machine/examples/github .  An example of creating a Github OAuth keymaker.",
            "title": "Github Keymaker Example"
        },
        {
            "location": "/keymaker_github/#creating-a-github-app",
            "text": "The brief summary of what we cover here:  We need to create an application (something that will consume the API\nendpoints), and we need to grant the application access to at least one \nGithub account.",
            "title": "Creating a Github App"
        },
        {
            "location": "/keymaker_github/#set-up-api-and-create-app",
            "text": "To create an OAuth app as a user, see  these detailed instructions \nfrom Github.  When you create your OAuth app, the one crucial\npiece of information is the callback URL. This is\nwhere the magic token is sent once the user logs in\nwith their Github account.  The Github Keymaker runs a server on localhost port 8000,\nso  the callback URL for your OAuth application should be \nset to  http://localhost:8000 .",
            "title": "Set Up API and Create App"
        },
        {
            "location": "/keymaker_github/#getting-app-credentials",
            "text": "Once you have created your application, the application's\ndescription page will contain the client ID and client secret\nneeded to use this application to run mind machine bots\nusing Github.",
            "title": "Getting App Credentials"
        },
        {
            "location": "/keymaker_github/#end-result",
            "text": "In the end you should have a pair of API keys (a client ID and\na client secret), which you will pass to the keymaker using\none of the three methods provided (via a dictionary, a JSON\nfile, or environment variables).  To run the Github Keymaker example, you need to pass the API\nkeys to the keymaker using one of three methods:   Using a dictionary  Using a JSON file  Using environment variables   To use the latter option, you can run the Github Keymaker program\nlike this:  $ CLIENT_ID=\"...\" CLIENT_SECRET=\"...\" python github_auth.py",
            "title": "End Result"
        },
        {
            "location": "/keymaker_github/#authorizing",
            "text": "To run this, you will need your client ID and client secret.\nThese can be found by logging in as the user that created the\nOAuth application you will be using, or that is an admin on the\norganization that owns the OAuth account. Go to the settings page\nand find the OAuth Applications listing on the left side. The\nOAuth application page will list the client ID and client secret\nat the top of the page.  Once you have them, set the  CLIENT_ID  and  CLIENT_SECRET  environment\nvariables when you run the program, like this:  $ CLIENT_ID=\"...\" \\\n  CLIENT_SECRET=\"...\" \\\n  python github_auth.py  This will create an authorization link, which you can log in to with\nany Github account. The Keymaker will create bot keys in  keys/ ,\nand will then clean up and remove the  keys/  directory.",
            "title": "Authorizing"
        },
        {
            "location": "/keymaker_google/",
            "text": "Google Keymaker Example\n\u00b6\n\n\nSee \nboring-mind-machine/examples/google\n.\n\n\nAn example of creating a Google OAuth keymaker.\n\n\nCreating a Google App\n\u00b6\n\n\nThe brief summary of what we cover here:\n\n\nWe need to create an application (something that will consume the API\nendpoints), and we need to grant the application access to at least one Google\naccount.\n\n\nSet Up API and Create App\n\u00b6\n\n\nThe first thing you must do is enable the APIs that you need.\nThis may include the Drive, Calendar, or other APIs.\nYou do this in the \nGoogle Cloud Platform (GCP) console\n.\n\n\nGo to the \nenable APIs\n\npage and select a project from the drop down menu.  If you do not already have\na project, go to the \nGCP console\n to create\na new one before visiting the enable APIs link above.\n\n\nCreating App Credentials\n\u00b6\n\n\nNow you will need to create OAuth credentials for your application. You can do this\non the API Credentials page. To get there, click the three-stack menu (a.k.a. the \n\"hamburger\" menu) and scroll down to the Products section and click \"APIs and Services\".\nNow click the \"Credentials\" option on the left side.\n\n\nNow create your credentials. Create \"OAuth Client ID\" credentials.\nUse application type \"Other\".\n\n\nWhen you create the credentials, you will be given a client ID and a client secret.\nCopy these into a password manager or other location.\n\n\nGetting the App Credentials\n\u00b6\n\n\nOnce you've created the credentials, you can either copy-and-paste the\nclient ID and client secret, or you can download them as a JSON file.\n\n\nTo copy-and-paste, find the OAuth client credentials you created in the\nprior step and click the pencil icon on the right side. This will take\nyou to a page with the client ID and client secret.\n\n\nTo download as a JSON file, download credentials using the download button\n(down-arrow icon) on the right side. This JSON file contains all credential\ninformation (client ID and client secret).\n\n\nRename it \nclient_secret.json\n.\n\n\nEnd Result\n\u00b6\n\n\nIn the end you will have a JSON file with your OAuth application credentials\nin it, and these will be used to authenticate with the user. The Google\nOAuth process will load the keys from \nclient_secret.json\n, and will\nopen a login link for the user to authenticate with their Google account.\n\n\nThe Google OAuth process also takes care of recieving the callback URL\nand the token contained in it, so the bot account keys are also stored in\na JSON file.\n\n\nNo environment variables need to be set, the only thing that needs to be set\nis the name of the JSON file containing the OAuth application's API credentials\n(should be \nclient_secret.json\n).\n\n\nOnce you have \nclient_secret.json\n in the current directory, you're set to go.\n\n\nAuthorizing\n\u00b6\n\n\nIn the authorization step the Keymaker generates a login link/token\nfor the user to visit and log in with their Google account. The user\nis then redirected back to the application with a token that can be\nused to perform actions on behalf of the account.\n\n\nGoogle requires the application's API keys to be provided via\na JSON file on disk.\n\n\nTo run the Google Keymaker example, specify the API key name in the\n\ngoogle_auth.py\n script (\nclient_secret.json\n by default):\n\n\n$ python google_auth.py",
            "title": "Google Keymaker"
        },
        {
            "location": "/keymaker_google/#google-keymaker-example",
            "text": "See  boring-mind-machine/examples/google .  An example of creating a Google OAuth keymaker.",
            "title": "Google Keymaker Example"
        },
        {
            "location": "/keymaker_google/#creating-a-google-app",
            "text": "The brief summary of what we cover here:  We need to create an application (something that will consume the API\nendpoints), and we need to grant the application access to at least one Google\naccount.",
            "title": "Creating a Google App"
        },
        {
            "location": "/keymaker_google/#set-up-api-and-create-app",
            "text": "The first thing you must do is enable the APIs that you need.\nThis may include the Drive, Calendar, or other APIs.\nYou do this in the  Google Cloud Platform (GCP) console .  Go to the  enable APIs \npage and select a project from the drop down menu.  If you do not already have\na project, go to the  GCP console  to create\na new one before visiting the enable APIs link above.",
            "title": "Set Up API and Create App"
        },
        {
            "location": "/keymaker_google/#creating-app-credentials",
            "text": "Now you will need to create OAuth credentials for your application. You can do this\non the API Credentials page. To get there, click the three-stack menu (a.k.a. the \n\"hamburger\" menu) and scroll down to the Products section and click \"APIs and Services\".\nNow click the \"Credentials\" option on the left side.  Now create your credentials. Create \"OAuth Client ID\" credentials.\nUse application type \"Other\".  When you create the credentials, you will be given a client ID and a client secret.\nCopy these into a password manager or other location.",
            "title": "Creating App Credentials"
        },
        {
            "location": "/keymaker_google/#getting-the-app-credentials",
            "text": "Once you've created the credentials, you can either copy-and-paste the\nclient ID and client secret, or you can download them as a JSON file.  To copy-and-paste, find the OAuth client credentials you created in the\nprior step and click the pencil icon on the right side. This will take\nyou to a page with the client ID and client secret.  To download as a JSON file, download credentials using the download button\n(down-arrow icon) on the right side. This JSON file contains all credential\ninformation (client ID and client secret).  Rename it  client_secret.json .",
            "title": "Getting the App Credentials"
        },
        {
            "location": "/keymaker_google/#end-result",
            "text": "In the end you will have a JSON file with your OAuth application credentials\nin it, and these will be used to authenticate with the user. The Google\nOAuth process will load the keys from  client_secret.json , and will\nopen a login link for the user to authenticate with their Google account.  The Google OAuth process also takes care of recieving the callback URL\nand the token contained in it, so the bot account keys are also stored in\na JSON file.  No environment variables need to be set, the only thing that needs to be set\nis the name of the JSON file containing the OAuth application's API credentials\n(should be  client_secret.json ).  Once you have  client_secret.json  in the current directory, you're set to go.",
            "title": "End Result"
        },
        {
            "location": "/keymaker_google/#authorizing",
            "text": "In the authorization step the Keymaker generates a login link/token\nfor the user to visit and log in with their Google account. The user\nis then redirected back to the application with a token that can be\nused to perform actions on behalf of the account.  Google requires the application's API keys to be provided via\na JSON file on disk.  To run the Google Keymaker example, specify the API key name in the google_auth.py  script ( client_secret.json  by default):  $ python google_auth.py",
            "title": "Authorizing"
        },
        {
            "location": "/keymaker_twitter/",
            "text": "Twitter Keymaker Example\n\u00b6\n\n\nSee \nboring-mind-machine/examples/twitter\n.\n\n\nAn example of creating a Twitter OAuth keymaker.\n\n\nSet Up API\n\u00b6\n\n\n(TODO: Instructions on turning on the API and how long it takes.)\n\n\nCreating a Twitter App\n\u00b6\n\n\n(TODO: The brief summary of creating a Twitter App.)\n\n\nGetting App Credentials\n\u00b6\n\n\nGet consumer token and consumer token secret.\n\n\nEnd result is you should have two pieces of information,\nwhich you can pass to the program using environment variables\n(easiest) or other methods.\n\n\nAuthorizing\n\u00b6\n\n\nIn the authorization step, the TwitterKeymaker generates a login link/token for\nthe user to visit and log in using their account. This then sends the user back\nto the application with a token.\n\n\nThe user can provide the application API keys to the Keymaker via file,\nenvironment variable, or dictionary. The TwitterKeymaker will use the\napplication API credentials and will guide the user through the process of\nauthenticating.  This uses Twitter's PIN-based authentication method.\n\n\n$ CONSUMER_TOKEN=\"...\" \\\n  CONSUMER_TOKEN_SECRET=\"...\" \\\n  python twitter_auth.py",
            "title": "Twitter Keymaker"
        },
        {
            "location": "/keymaker_twitter/#twitter-keymaker-example",
            "text": "See  boring-mind-machine/examples/twitter .  An example of creating a Twitter OAuth keymaker.",
            "title": "Twitter Keymaker Example"
        },
        {
            "location": "/keymaker_twitter/#set-up-api",
            "text": "(TODO: Instructions on turning on the API and how long it takes.)",
            "title": "Set Up API"
        },
        {
            "location": "/keymaker_twitter/#creating-a-twitter-app",
            "text": "(TODO: The brief summary of creating a Twitter App.)",
            "title": "Creating a Twitter App"
        },
        {
            "location": "/keymaker_twitter/#getting-app-credentials",
            "text": "Get consumer token and consumer token secret.  End result is you should have two pieces of information,\nwhich you can pass to the program using environment variables\n(easiest) or other methods.",
            "title": "Getting App Credentials"
        },
        {
            "location": "/keymaker_twitter/#authorizing",
            "text": "In the authorization step, the TwitterKeymaker generates a login link/token for\nthe user to visit and log in using their account. This then sends the user back\nto the application with a token.  The user can provide the application API keys to the Keymaker via file,\nenvironment variable, or dictionary. The TwitterKeymaker will use the\napplication API credentials and will guide the user through the process of\nauthenticating.  This uses Twitter's PIN-based authentication method.  $ CONSUMER_TOKEN=\"...\" \\\n  CONSUMER_TOKEN_SECRET=\"...\" \\\n  python twitter_auth.py",
            "title": "Authorizing"
        },
        {
            "location": "/boring_shepherd/",
            "text": "Boring Shepherd\n\u00b6\n\n\nThe Shepherd class spins up the flock of Sheep \nand lets them roam free.\n\n\nThe BoringShepherd class leaves the details of creating Sheep\nto the user, but still defines some useful methods. \n\n\nThe constructor calls a method to setup the flock.\nThe method to setup the flock loops over each key.\n\n\nFor each key, it:\n- validates the key\n- creates a Sheep from the key\n\n\nThere are also two methods to perform actions with the flock:\none for serial and one for parallel.\n\n\nConstructor\n\u00b6\n\n\nThis defines a generic Shepherd constructor that takes the following\nparameters:\n\n\n\n\njson_keys_dir\n: Directory where Sheep API keys are located\n\n\nflock_name\n: The name of the bot flock (used to format log messages)\n\n\nsheep_class\n: Type of Sheep\n\n\n**kwargs\n: Logging parameters passed directly to Lumberjack logger\n\n\n\n\nExample:\n\n\nSuppose we have the following directory structure:\n\n\n$ ls keys/\nbot_key1.json\nbot_key2.json\nbot_key3.json\n\n\n\n\n\nConstructor Call Order\n\u00b6\n\n\nThe call order for the constructor is as follows:\n\n\n\n\nShepherd contructor calls \ncreate_flock()\n method\n\n\ncreate_flock()\n method loads each key in a directory and calls two methods:\n\n\nPrivate method \n_validate_key()\n is called to check the bot key\n\n\nPrivate method \n_create_sheep()\n is called to create the Sheep\n\n\n\n\n\n\n\n\nTo extend the BoringShepherd class,\nyou must extend both the \n_create_sheep()\n\nand \n_validate_key()\n classes (they are \nundefined/virtual methods in the base class).\n\n\nExample:\n\n\nSuppose we have the following directory structure:\n\n\n$ ls keys/\nbot_key1.json\nbot_key2.json\nbot_key3.json\n\n\n\n\n\nNow we create a custom Shepherd class that extends the\n\n_create_sheep()\n and \n_validate_key()\n methods,\nand use the custom Shepherd class to \n\n\n(We illustrate performing basic key validation by filtering\nkeys with a particular name.)\n\n\nimport boringmindmachine as bmm\n\nclass BlueShepherd(bmm.BoringShepherd):\n    def _create_sheep(self):\n        pass\n    def _validate_key(self):\n        pass\n\nif __name__==\"__main__\":\n    s = BlueShepherd( a, b, c )\n\n\n\n\n\nPerforming Actions\n\u00b6\n\n\nThe Shepherd and Sheep use the dispatcher pattern\nto call methods. The dispatcher pattern is used to\nturn a string (like \"tweet\") into a function call\n(like \ntweet()\n).\n\n\nimport boringmindmachine as bmm\nimport time\n\nclass FlatulentSheep(bmm.BoringSheep):\n    def pass_gas(self):\n        print(\"pfffft\")\n        time.sleep(30)\n\nif __name__==\"__name__\":\n    s = bmm.BoringShepherd(\n                keys_dir = \"keys/\",\n                flock_name = \"flatulent_flock\",\n                sheep_class = FlatulentSheep\n    )\n\n\n\n\n\n(TODO: Finish these examples.)",
            "title": "Boring Shepherd"
        },
        {
            "location": "/boring_shepherd/#boring-shepherd",
            "text": "The Shepherd class spins up the flock of Sheep \nand lets them roam free.  The BoringShepherd class leaves the details of creating Sheep\nto the user, but still defines some useful methods.   The constructor calls a method to setup the flock.\nThe method to setup the flock loops over each key.  For each key, it:\n- validates the key\n- creates a Sheep from the key  There are also two methods to perform actions with the flock:\none for serial and one for parallel.",
            "title": "Boring Shepherd"
        },
        {
            "location": "/boring_shepherd/#constructor",
            "text": "This defines a generic Shepherd constructor that takes the following\nparameters:   json_keys_dir : Directory where Sheep API keys are located  flock_name : The name of the bot flock (used to format log messages)  sheep_class : Type of Sheep  **kwargs : Logging parameters passed directly to Lumberjack logger   Example:  Suppose we have the following directory structure:  $ ls keys/\nbot_key1.json\nbot_key2.json\nbot_key3.json",
            "title": "Constructor"
        },
        {
            "location": "/boring_shepherd/#constructor-call-order",
            "text": "The call order for the constructor is as follows:   Shepherd contructor calls  create_flock()  method  create_flock()  method loads each key in a directory and calls two methods:  Private method  _validate_key()  is called to check the bot key  Private method  _create_sheep()  is called to create the Sheep     To extend the BoringShepherd class,\nyou must extend both the  _create_sheep() \nand  _validate_key()  classes (they are \nundefined/virtual methods in the base class).  Example:  Suppose we have the following directory structure:  $ ls keys/\nbot_key1.json\nbot_key2.json\nbot_key3.json  Now we create a custom Shepherd class that extends the _create_sheep()  and  _validate_key()  methods,\nand use the custom Shepherd class to   (We illustrate performing basic key validation by filtering\nkeys with a particular name.)  import boringmindmachine as bmm\n\nclass BlueShepherd(bmm.BoringShepherd):\n    def _create_sheep(self):\n        pass\n    def _validate_key(self):\n        pass\n\nif __name__==\"__main__\":\n    s = BlueShepherd( a, b, c )",
            "title": "Constructor Call Order"
        },
        {
            "location": "/boring_shepherd/#performing-actions",
            "text": "The Shepherd and Sheep use the dispatcher pattern\nto call methods. The dispatcher pattern is used to\nturn a string (like \"tweet\") into a function call\n(like  tweet() ).  import boringmindmachine as bmm\nimport time\n\nclass FlatulentSheep(bmm.BoringSheep):\n    def pass_gas(self):\n        print(\"pfffft\")\n        time.sleep(30)\n\nif __name__==\"__name__\":\n    s = bmm.BoringShepherd(\n                keys_dir = \"keys/\",\n                flock_name = \"flatulent_flock\",\n                sheep_class = FlatulentSheep\n    )  (TODO: Finish these examples.)",
            "title": "Performing Actions"
        },
        {
            "location": "/boring_sheep/",
            "text": "The Sheep\n\u00b6\n\n\n(TODO: Copy Sheep materials over, and copy Shepherd docs)\n\n\n(TODO: What are the most common ways to extend Sheep? essential methods/call\ntraces?)\n\n\nThe Sheep is the class that represents a single user account on the\nthird party service the mind machine is defining. In general, the pattern\nthat mind machine bot flocks follow is: 1 Sheep = 1 bot account = 1 action.\n\n\nBecause Sheep can do anything, we don't want to impose restrictions by\nimplementing functionality here.\n\n\nHow to use the Boring Sheep? (don't)\n\u00b6\n\n\nThe constructor is where you create the Sheep's API instance, and should be\ndefined at the package level.\n\n\nThe BoringSheep class has a virtual constructor, so it cannot be created\ndirectly. You should instead define a new Sheep class that inherits from\nBoringSheep and defines a constructor, which should initialize an API instance.\n\n\nHow to extend the Boring Sheep?\n\u00b6\n\n\nWhat does the Boring Sheep define?\n\u00b6\n\n\nIn addition to mentioning what you have to define,\nlet's mention what you don't have to define.\n\n\nThe BoringSheep class implements a dispatcher pattern,\nwhich is a way of passing the name of an action as a\nstring, and turning that into a function call.\n\n\nFor example, if the user asks for the 'dummy' action\nvia \nsheep.perform_action('dummy',**kwargs)\n, this will \ncall \nsheep.dummy(**kwargs)\n.\n\n\nSee \ncommand pattern (wikipedia)\n\nfor a detailed description of the dispatcher pattern.\n\n\n    \ndef\n \nperform_action\n(\nself\n,\naction\n,\n**\nkwargs\n):\n\n        \n# Dispatcher pattern\n\n        \nif\n \nhasattr\n(\nself\n,\n \naction\n):\n\n            \nmethod\n \n=\n \ngetattr\n(\nself\n,\n \naction\n)\n\n            \nmethod\n(\n**\nkwargs\n)",
            "title": "Boring Sheep"
        },
        {
            "location": "/boring_sheep/#the-sheep",
            "text": "(TODO: Copy Sheep materials over, and copy Shepherd docs)  (TODO: What are the most common ways to extend Sheep? essential methods/call\ntraces?)  The Sheep is the class that represents a single user account on the\nthird party service the mind machine is defining. In general, the pattern\nthat mind machine bot flocks follow is: 1 Sheep = 1 bot account = 1 action.  Because Sheep can do anything, we don't want to impose restrictions by\nimplementing functionality here.",
            "title": "The Sheep"
        },
        {
            "location": "/boring_sheep/#how-to-use-the-boring-sheep-dont",
            "text": "The constructor is where you create the Sheep's API instance, and should be\ndefined at the package level.  The BoringSheep class has a virtual constructor, so it cannot be created\ndirectly. You should instead define a new Sheep class that inherits from\nBoringSheep and defines a constructor, which should initialize an API instance.",
            "title": "How to use the Boring Sheep? (don't)"
        },
        {
            "location": "/boring_sheep/#how-to-extend-the-boring-sheep",
            "text": "",
            "title": "How to extend the Boring Sheep?"
        },
        {
            "location": "/boring_sheep/#what-does-the-boring-sheep-define",
            "text": "In addition to mentioning what you have to define,\nlet's mention what you don't have to define.  The BoringSheep class implements a dispatcher pattern,\nwhich is a way of passing the name of an action as a\nstring, and turning that into a function call.  For example, if the user asks for the 'dummy' action\nvia  sheep.perform_action('dummy',**kwargs) , this will \ncall  sheep.dummy(**kwargs) .  See  command pattern (wikipedia) \nfor a detailed description of the dispatcher pattern.       def   perform_action ( self , action , ** kwargs ): \n         # Dispatcher pattern \n         if   hasattr ( self ,   action ): \n             method   =   getattr ( self ,   action ) \n             method ( ** kwargs )",
            "title": "What does the Boring Sheep define?"
        },
        {
            "location": "/future/",
            "text": "Future Work and Ideas\n\u00b6\n\n\n(TODO: add future work and ideas)",
            "title": "Future Work and Ideas"
        },
        {
            "location": "/future/#future-work-and-ideas",
            "text": "(TODO: add future work and ideas)",
            "title": "Future Work and Ideas"
        },
        {
            "location": "/credits/",
            "text": "Credits\n\u00b6\n\n\n(TODO: add credits)",
            "title": "Credits"
        },
        {
            "location": "/credits/#credits",
            "text": "(TODO: add credits)",
            "title": "Credits"
        },
        {
            "location": "/contributing/",
            "text": "Contributing\n\u00b6\n\n\n(TODO: add contributing message)",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#contributing",
            "text": "(TODO: add contributing message)",
            "title": "Contributing"
        },
        {
            "location": "/mind-machine-docs/dev/",
            "text": "Developer Notes\n\u00b6\n\n\nMakefiles:\n\n\n\n\nMakefile rules after first clone\n\n\nMakefile rules after fresh clone\n\n\nMakefile rules for test/deploy/docs\n\n\n\n\nPrime nubmer version system\n\n\n\n\nPrime number version system repository\n\n\nShould describe workflows and give overview of tasks\n\n\n\n\nTesting:\n\n\n\n\nUsing examples to test interactivity\n\n\nTests are mainly smoke tests\n\n\nFor complicated example, see bear/python-twitter on Github\n\n\n\n\nReleases:\n\n\n\n\nGithub releases\n\n\nPypi upload\n\n\nDockerhub (just an explanation of how it works/webhook)\n\n\n\n\nDocker:\n\n\n\n\nDeveloper considerations for docker container",
            "title": "Developer Notes"
        },
        {
            "location": "/mind-machine-docs/dev/#developer-notes",
            "text": "Makefiles:   Makefile rules after first clone  Makefile rules after fresh clone  Makefile rules for test/deploy/docs   Prime nubmer version system   Prime number version system repository  Should describe workflows and give overview of tasks   Testing:   Using examples to test interactivity  Tests are mainly smoke tests  For complicated example, see bear/python-twitter on Github   Releases:   Github releases  Pypi upload  Dockerhub (just an explanation of how it works/webhook)   Docker:   Developer considerations for docker container",
            "title": "Developer Notes"
        }
    ]
}