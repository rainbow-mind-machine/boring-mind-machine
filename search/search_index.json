{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"boring-mind-machine \u00b6 boring mind machine is a set of boring base classes for building awesome bot flocks. Other mind machine libraries utilize the boring mind machine library's classes as a starting point for implementing bot flocks. For example, rainbow mind machine utilizes the TwitterKeymaker class defined in this library; embarcadero mind machine utilizes the GithubKeymaker class; and so on. All the shields \u00b6 Links \u00b6 boring mind machine (bmm) links: bmm source code on Github bmm documentation rainbow mind machine organization on Github releases: bmm releases on Github bmm on pypi bmm on dockerhub Pages \u00b6 About the Mind Machine Framework - general information about the mind machine framework (how does it work? what does it look like?) About Boring Mind Machine - about the boring mind machine library (what is it? what does it do?) Installing - installation instructions (how do I install bmm?) Quick Start - quick start instructions for getting started with boring mind machine base classes (how do I run bmm?) Documentation for components implemented in boring mind machine: Keymakers: bmm.BoringKeymaker bmm.BoringOAuthKeymaker bmm.BoringShepherd bmm.BoringSheep Contributing Developer Notes - notes on processes for developers (how do I run tests, update packages/images, build documentation, etc.?)","title":"Home"},{"location":"#boring-mind-machine","text":"boring mind machine is a set of boring base classes for building awesome bot flocks. Other mind machine libraries utilize the boring mind machine library's classes as a starting point for implementing bot flocks. For example, rainbow mind machine utilizes the TwitterKeymaker class defined in this library; embarcadero mind machine utilizes the GithubKeymaker class; and so on.","title":"boring-mind-machine"},{"location":"#all-the-shields","text":"","title":"All the shields"},{"location":"#links","text":"boring mind machine (bmm) links: bmm source code on Github bmm documentation rainbow mind machine organization on Github releases: bmm releases on Github bmm on pypi bmm on dockerhub","title":"Links"},{"location":"#pages","text":"About the Mind Machine Framework - general information about the mind machine framework (how does it work? what does it look like?) About Boring Mind Machine - about the boring mind machine library (what is it? what does it do?) Installing - installation instructions (how do I install bmm?) Quick Start - quick start instructions for getting started with boring mind machine base classes (how do I run bmm?) Documentation for components implemented in boring mind machine: Keymakers: bmm.BoringKeymaker bmm.BoringOAuthKeymaker bmm.BoringShepherd bmm.BoringSheep Contributing Developer Notes - notes on processes for developers (how do I run tests, update packages/images, build documentation, etc.?)","title":"Pages"},{"location":"about/","text":"About boring mind machine \u00b6 boring mind machine (bmm) is part of the mind machine suite of software, run by the rainbow-mind-machine organization on Github. Like all mind machines, boring mind machine is simple and extensible. How is boring mind machine simple? \u00b6 The mind machine framework revolves around providing a few simple components for building bot flocks: Keymaker classes Shepherd classes Sheep classes But it gets even simpler than that: boring-mind-machine provides a GithubKeymaker class , so that embarcadero mind machine can focus exclusively on Shepherd and Sheep classes. That's pretty simple! What does boring mind machine extend or do? \u00b6 The main job of boring mind machine is to take care of the boring stuff. That means two things: Setting up boring base classes that are designed to be extended by all of the other mind machine libraries; and Providing working OAuth Keymakers for every third-party service provider that has its own mind machine library. (Github, Google, Twitter, etc.) Base classes \u00b6 Because boring mind machine provides base classes, that means it does not extend classes - it provides the base classes that are extended. That makes boring mind machine unique among the mind machines - every mind machine library imports boring mind machine no matter what, and every Keymaker is defined in boring mind machine. OAuth Keymakers \u00b6 The second, most important functionality implemented in bmm are the Keymaker classes. bmm implements a Keymaker for each service that has a corresponding mind machine library. Collecting each Keymaker together makes the logic more clear. Each third party service implements the same authentication process (OAuth) but everybody does it differently, so there are many tedious, boring details to work out. Hence, the \"boring\". How is boring mind machine POOP-y? \u00b6 Libraries that implement good practices in POOP (Python Object Oriented Programming) are said to be POOP-y. What makes the boring mind machine library particularly POOP-y is the fact that it provides the solid foundation on which the entire mind machine enterprise is constructed. It is critical that the boring mind machine library be an exemplar of good practices for software built using the mind machine framework!","title":"About bmm"},{"location":"about/#about-boring-mind-machine","text":"boring mind machine (bmm) is part of the mind machine suite of software, run by the rainbow-mind-machine organization on Github. Like all mind machines, boring mind machine is simple and extensible.","title":"About boring mind machine"},{"location":"about/#how-is-boring-mind-machine-simple","text":"The mind machine framework revolves around providing a few simple components for building bot flocks: Keymaker classes Shepherd classes Sheep classes But it gets even simpler than that: boring-mind-machine provides a GithubKeymaker class , so that embarcadero mind machine can focus exclusively on Shepherd and Sheep classes. That's pretty simple!","title":"How is boring mind machine simple?"},{"location":"about/#what-does-boring-mind-machine-extend-or-do","text":"The main job of boring mind machine is to take care of the boring stuff. That means two things: Setting up boring base classes that are designed to be extended by all of the other mind machine libraries; and Providing working OAuth Keymakers for every third-party service provider that has its own mind machine library. (Github, Google, Twitter, etc.)","title":"What does boring mind machine extend or do?"},{"location":"about/#base-classes","text":"Because boring mind machine provides base classes, that means it does not extend classes - it provides the base classes that are extended. That makes boring mind machine unique among the mind machines - every mind machine library imports boring mind machine no matter what, and every Keymaker is defined in boring mind machine.","title":"Base classes"},{"location":"about/#oauth-keymakers","text":"The second, most important functionality implemented in bmm are the Keymaker classes. bmm implements a Keymaker for each service that has a corresponding mind machine library. Collecting each Keymaker together makes the logic more clear. Each third party service implements the same authentication process (OAuth) but everybody does it differently, so there are many tedious, boring details to work out. Hence, the \"boring\".","title":"OAuth Keymakers"},{"location":"about/#how-is-boring-mind-machine-poop-y","text":"Libraries that implement good practices in POOP (Python Object Oriented Programming) are said to be POOP-y. What makes the boring mind machine library particularly POOP-y is the fact that it provides the solid foundation on which the entire mind machine enterprise is constructed. It is critical that the boring mind machine library be an exemplar of good practices for software built using the mind machine framework!","title":"How is boring mind machine POOP-y?"},{"location":"bmm_keymaker/","text":"Boring Keymaker and Boring OAuth Keymaker \u00b6 the mind machine keymaker. trust it with your keys. There are two base Keymaker classes implemented by boring mind machine; they are BoringKeymaker and BoringOAuthKeymaker . Technically a Keymaker can inherit from BoringKeymaker and use any authentication method, but in practice all Keymakers are OAuth Keymakers. Constructing the Keymaker \u00b6 The generic BoringOAuthKeymaker class requires two bits of information: an API application token and an API application secret. These have different names for different services, so when you create a Keymaker, you need to specify the name of the token and the name of the secret in the Keymaker constructor: import boringmindmachine as bmm # create a dummy oauth keymaker class class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) For Github, Google, Twitter, etc. Keymakers, this value is already set. import boringmindmachine as bmm ghk = bmm . GithubKeymaker () gk = bmm . GoogleKeymaker () tk = bmm . TwitterKeymaker () Passing API Keys to the Keymaker \u00b6 The Keymaker must have client API keys to verify that it is in fact allowed to take actions as the third-party OAuth application. The API keys consist of a token and a secret that correspond to the OAuth app created for the third-party service. (For example, when you create a Github app, the app page will give a client ID and a client secret at the top of the page.) This token and secret can be passed three different ways: via environment variables via a JSON file via a Python dictionary Using Environment Variables \u00b6 To set using environment variables: use_env.py : import boringmindmachine as bmm class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) k . set_apikeys_env () This would then look for two environment variables corresponding to the name of the token and secret in all caps. In the above case, we would need to run the script and provide the API keys as follows: $ CLIENT_TOKEN=\"abcd\" CLIENT_SECRET=\"qwerty\" use_env.py Using JSON File \u00b6 To use a JSON file, create a simple JSON file with two key-value pairs. The two keys should be the token name and the secret name provided to the constructor. apikeys.json : { \"client_token\" : \"asdf\" , \"client_secret\" : \"qwerty\" } The corresponding call to set the Keymaker API tokens would look like: use_json.py : import boringmindmachine as bmm class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) k . set_apikeys_json ( 'apikeys.json' ) Using Python Dict \u00b6 use_dict.py : import boringmindmachine as bmm class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) k . set_apikeys_dict ({ 'client_token' : 'asdf' , 'client_secret' : 'qwerty' })","title":"Boring OAuth Keymaker"},{"location":"bmm_keymaker/#boring-keymaker-and-boring-oauth-keymaker","text":"the mind machine keymaker. trust it with your keys. There are two base Keymaker classes implemented by boring mind machine; they are BoringKeymaker and BoringOAuthKeymaker . Technically a Keymaker can inherit from BoringKeymaker and use any authentication method, but in practice all Keymakers are OAuth Keymakers.","title":"Boring Keymaker and Boring OAuth Keymaker"},{"location":"bmm_keymaker/#constructing-the-keymaker","text":"The generic BoringOAuthKeymaker class requires two bits of information: an API application token and an API application secret. These have different names for different services, so when you create a Keymaker, you need to specify the name of the token and the name of the secret in the Keymaker constructor: import boringmindmachine as bmm # create a dummy oauth keymaker class class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) For Github, Google, Twitter, etc. Keymakers, this value is already set. import boringmindmachine as bmm ghk = bmm . GithubKeymaker () gk = bmm . GoogleKeymaker () tk = bmm . TwitterKeymaker ()","title":"Constructing the Keymaker"},{"location":"bmm_keymaker/#passing-api-keys-to-the-keymaker","text":"The Keymaker must have client API keys to verify that it is in fact allowed to take actions as the third-party OAuth application. The API keys consist of a token and a secret that correspond to the OAuth app created for the third-party service. (For example, when you create a Github app, the app page will give a client ID and a client secret at the top of the page.) This token and secret can be passed three different ways: via environment variables via a JSON file via a Python dictionary","title":"Passing API Keys to the Keymaker"},{"location":"bmm_keymaker/#using-environment-variables","text":"To set using environment variables: use_env.py : import boringmindmachine as bmm class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) k . set_apikeys_env () This would then look for two environment variables corresponding to the name of the token and secret in all caps. In the above case, we would need to run the script and provide the API keys as follows: $ CLIENT_TOKEN=\"abcd\" CLIENT_SECRET=\"qwerty\" use_env.py","title":"Using Environment Variables"},{"location":"bmm_keymaker/#using-json-file","text":"To use a JSON file, create a simple JSON file with two key-value pairs. The two keys should be the token name and the secret name provided to the constructor. apikeys.json : { \"client_token\" : \"asdf\" , \"client_secret\" : \"qwerty\" } The corresponding call to set the Keymaker API tokens would look like: use_json.py : import boringmindmachine as bmm class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) k . set_apikeys_json ( 'apikeys.json' )","title":"Using JSON File"},{"location":"bmm_keymaker/#using-python-dict","text":"use_dict.py : import boringmindmachine as bmm class MyKeymaker ( bmm . BoringOAuthKeymaker ): pass k = MyKeymaker ( token = 'client_token' , secret = 'client_secret' ) k . set_apikeys_dict ({ 'client_token' : 'asdf' , 'client_secret' : 'qwerty' })","title":"Using Python Dict"},{"location":"bmm_sheep/","text":"Boring Sheep \u00b6 The mind machine sheep. (TODO: Copy Sheep materials over, and copy Shepherd docs) (TODO: What are the most common ways to extend Sheep? essential methods/call traces?) The Sheep is the class that represents a single user account on the third party service the mind machine is defining. In general, the pattern that mind machine bot flocks follow is: 1 Sheep = 1 bot account = 1 action. The BoringSheep class is really boring, because we don't want to impose restrictions or make assumptions by implementing a bunch of functionality. How to use the Boring Sheep class? (...don't) \u00b6 The constructor is where you create the Sheep's API instance, and should be defined at the package level. The Boring Sheep class has a virtual constructor, so it cannot be created directly. You should instead define a new Sheep class that inherits from Boring Sheep and defines a constructor, which should initialize an API instance. How to extend the Boring Sheep class? \u00b6 See the examples/ directory. What does the Boring Sheep class define? \u00b6 In addition to mentioning what you have to define, let's mention what you don't have to define. The Boring Sheep class implements a dispatcher pattern, which is a way of passing the name of an action as a string, and turning that into a function call. For example, if the user asks for the 'dummy' action via sheep.perform_action('dummy',**kwargs) , this will call sheep.dummy(**kwargs) . See command pattern (wikipedia) for a detailed description of the dispatcher pattern. def perform_action ( self , action , ** kwargs ): # Dispatcher pattern if hasattr ( self , action ): method = getattr ( self , action ) method ( ** kwargs )","title":"Boring Sheep"},{"location":"bmm_sheep/#boring-sheep","text":"The mind machine sheep. (TODO: Copy Sheep materials over, and copy Shepherd docs) (TODO: What are the most common ways to extend Sheep? essential methods/call traces?) The Sheep is the class that represents a single user account on the third party service the mind machine is defining. In general, the pattern that mind machine bot flocks follow is: 1 Sheep = 1 bot account = 1 action. The BoringSheep class is really boring, because we don't want to impose restrictions or make assumptions by implementing a bunch of functionality.","title":"Boring Sheep"},{"location":"bmm_sheep/#how-to-use-the-boring-sheep-class-dont","text":"The constructor is where you create the Sheep's API instance, and should be defined at the package level. The Boring Sheep class has a virtual constructor, so it cannot be created directly. You should instead define a new Sheep class that inherits from Boring Sheep and defines a constructor, which should initialize an API instance.","title":"How to use the Boring Sheep class? (...don't)"},{"location":"bmm_sheep/#how-to-extend-the-boring-sheep-class","text":"See the examples/ directory.","title":"How to extend the Boring Sheep class?"},{"location":"bmm_sheep/#what-does-the-boring-sheep-class-define","text":"In addition to mentioning what you have to define, let's mention what you don't have to define. The Boring Sheep class implements a dispatcher pattern, which is a way of passing the name of an action as a string, and turning that into a function call. For example, if the user asks for the 'dummy' action via sheep.perform_action('dummy',**kwargs) , this will call sheep.dummy(**kwargs) . See command pattern (wikipedia) for a detailed description of the dispatcher pattern. def perform_action ( self , action , ** kwargs ): # Dispatcher pattern if hasattr ( self , action ): method = getattr ( self , action ) method ( ** kwargs )","title":"What does the Boring Sheep class define?"},{"location":"bmm_shepherd/","text":"Boring Shepherd \u00b6 The shepherd's ( pasteur ) power manifests itself, therefore, in a duty, a task to be undertaken, so that - and I think this is also an important characteristic of pastoral power - the form it takes is not first of all the striking display of strength and superiority. Pastoral power initially manifests itself in its zeal, devotion, and endless application. What is the shepherd ( berger )? Is (s)he someone whose strength strikes people's eyes, like the sovereigns or gods, like the Greek gods, who essentially appear in their splendor? Not at all. The shepherd is someone who keeps watch. (S)he \"keeps watch\" in the sense, of course, of keeping an eye out for possible evils, but above all in the sense of vigilance with regard to any possible misfortune. Michel Foucault, Security, Territory, Population: Lectures at the Coll\u00e9ge de France (1977-1978) The mind machine shepherd. The Shepherd class spins up the flock of Sheep and lets them roam free. The BoringShepherd class leaves the details of creating Sheep to the user, but still defines some useful methods. The constructor calls a method to setup the flock. The method to setup the flock loops over each key. For each key, it: validates the key creates a Sheep from the key There are also two methods to perform actions with the flock: one for serial and one for parallel. Constructor \u00b6 This defines a generic Shepherd constructor that takes the following parameters: json_keys_dir : Directory where Sheep API keys are located flock_name : The name of the bot flock (used to format log messages) sheep_class : Type of Sheep **kwargs : Logging parameters passed directly to Lumberjack logger Example: Suppose we have the following directory structure: $ ls keys/ bot_key1.json bot_key2.json bot_key3.json Constructor Call Order \u00b6 The call order for the constructor is as follows: Shepherd contructor calls create_flock() method create_flock() method loads each key in a directory and calls two methods: Private method _validate_key() is called to check the bot key Private method _create_sheep() is called to create the Sheep To extend the BoringShepherd class, you must extend both the _create_sheep() and _validate_key() classes (they are undefined/virtual methods in the base class). Example: Suppose we have the following directory structure: $ ls keys/ bot_key1.json bot_key2.json bot_key3.json Now we create a custom Shepherd class that extends the _create_sheep() and _validate_key() methods, and use the custom Shepherd class to (We illustrate performing basic key validation by checking for keys with a particular name.) import boringmindmachine as bmm class BlueShepherd ( bmm . BoringShepherd ): def _validate_key ( self , bot_key , ** kwargs ): \"\"\" Validate a bot key, passed in as a dictionary. Sole purpose of this function: raise an exception if there is a problem. \"\"\" required_keys = [ 'key1' , 'key2' , 'key3' ] for key in required_keys : if key not in bot_key . keys (): err = \"ERROR: the bot key is missing a required key ' %s '.\" % ( key ) raise Exception ( err ) def _create_sheep ( self ): sheep = self . sheep_class ( bot_key ) self . flock . append ( sheep ) Performing Actions \u00b6 The Shepherd and Sheep use the dispatcher pattern to call methods. The dispatcher pattern is used to turn a string (like \"tweet\") into a function call (like tweet() ). import boringmindmachine as bmm import time class FlatulentSheep ( bmm . BoringSheep ): def pass_gas ( self ): print ( \"pfffft\" ) time . sleep ( 30 ) if __name__ == \"__name__\" : s = bmm . BoringShepherd ( keys_dir = \"keys/\" , flock_name = \"flatulent_flock\" , sheep_class = FlatulentSheep ) s . perform_parallel_action ( 'pass_gas' ) Adding Parameters to Actions \u00b6 If we wanted to add a parameter with a default value (for example, the string being printed by pass_gas() ), we can use **kwargs as follows; import boringmindmachine as bmm import time class FlatulentSheep ( bmm . BoringSheep ): def pass_gas ( self ,, ** kwargs ): if 'message' in kwargs : msg = kwargs [ 'message' ] else : msg = 'pfffffft' print ( msg ) time . sleep ( 30 ) if __name__ == \"__name__\" : s = bmm . BoringShepherd ( keys_dir = \"keys/\" , flock_name = \"flatulent_flock\" , sheep_class = FlatulentSheep ) s . perform_parallel_action ( 'pass_gas' , message = 'FFFRRRRRRRRRAAAAAAAPPPPPPP' )","title":"Boring Shepherd"},{"location":"bmm_shepherd/#boring-shepherd","text":"The shepherd's ( pasteur ) power manifests itself, therefore, in a duty, a task to be undertaken, so that - and I think this is also an important characteristic of pastoral power - the form it takes is not first of all the striking display of strength and superiority. Pastoral power initially manifests itself in its zeal, devotion, and endless application. What is the shepherd ( berger )? Is (s)he someone whose strength strikes people's eyes, like the sovereigns or gods, like the Greek gods, who essentially appear in their splendor? Not at all. The shepherd is someone who keeps watch. (S)he \"keeps watch\" in the sense, of course, of keeping an eye out for possible evils, but above all in the sense of vigilance with regard to any possible misfortune. Michel Foucault, Security, Territory, Population: Lectures at the Coll\u00e9ge de France (1977-1978) The mind machine shepherd. The Shepherd class spins up the flock of Sheep and lets them roam free. The BoringShepherd class leaves the details of creating Sheep to the user, but still defines some useful methods. The constructor calls a method to setup the flock. The method to setup the flock loops over each key. For each key, it: validates the key creates a Sheep from the key There are also two methods to perform actions with the flock: one for serial and one for parallel.","title":"Boring Shepherd"},{"location":"bmm_shepherd/#constructor","text":"This defines a generic Shepherd constructor that takes the following parameters: json_keys_dir : Directory where Sheep API keys are located flock_name : The name of the bot flock (used to format log messages) sheep_class : Type of Sheep **kwargs : Logging parameters passed directly to Lumberjack logger Example: Suppose we have the following directory structure: $ ls keys/ bot_key1.json bot_key2.json bot_key3.json","title":"Constructor"},{"location":"bmm_shepherd/#constructor-call-order","text":"The call order for the constructor is as follows: Shepherd contructor calls create_flock() method create_flock() method loads each key in a directory and calls two methods: Private method _validate_key() is called to check the bot key Private method _create_sheep() is called to create the Sheep To extend the BoringShepherd class, you must extend both the _create_sheep() and _validate_key() classes (they are undefined/virtual methods in the base class). Example: Suppose we have the following directory structure: $ ls keys/ bot_key1.json bot_key2.json bot_key3.json Now we create a custom Shepherd class that extends the _create_sheep() and _validate_key() methods, and use the custom Shepherd class to (We illustrate performing basic key validation by checking for keys with a particular name.) import boringmindmachine as bmm class BlueShepherd ( bmm . BoringShepherd ): def _validate_key ( self , bot_key , ** kwargs ): \"\"\" Validate a bot key, passed in as a dictionary. Sole purpose of this function: raise an exception if there is a problem. \"\"\" required_keys = [ 'key1' , 'key2' , 'key3' ] for key in required_keys : if key not in bot_key . keys (): err = \"ERROR: the bot key is missing a required key ' %s '.\" % ( key ) raise Exception ( err ) def _create_sheep ( self ): sheep = self . sheep_class ( bot_key ) self . flock . append ( sheep )","title":"Constructor Call Order"},{"location":"bmm_shepherd/#performing-actions","text":"The Shepherd and Sheep use the dispatcher pattern to call methods. The dispatcher pattern is used to turn a string (like \"tweet\") into a function call (like tweet() ). import boringmindmachine as bmm import time class FlatulentSheep ( bmm . BoringSheep ): def pass_gas ( self ): print ( \"pfffft\" ) time . sleep ( 30 ) if __name__ == \"__name__\" : s = bmm . BoringShepherd ( keys_dir = \"keys/\" , flock_name = \"flatulent_flock\" , sheep_class = FlatulentSheep ) s . perform_parallel_action ( 'pass_gas' )","title":"Performing Actions"},{"location":"bmm_shepherd/#adding-parameters-to-actions","text":"If we wanted to add a parameter with a default value (for example, the string being printed by pass_gas() ), we can use **kwargs as follows; import boringmindmachine as bmm import time class FlatulentSheep ( bmm . BoringSheep ): def pass_gas ( self ,, ** kwargs ): if 'message' in kwargs : msg = kwargs [ 'message' ] else : msg = 'pfffffft' print ( msg ) time . sleep ( 30 ) if __name__ == \"__name__\" : s = bmm . BoringShepherd ( keys_dir = \"keys/\" , flock_name = \"flatulent_flock\" , sheep_class = FlatulentSheep ) s . perform_parallel_action ( 'pass_gas' , message = 'FFFRRRRRRRRRAAAAAAAPPPPPPP' )","title":"Adding Parameters to Actions"},{"location":"contributing/","text":"Contributing \u00b6 Ways to Contribute \u00b6 Some ways that you can contribute, in order of increasing involvement: Read the documentation ! If you find a problem or can't understand something, open an issue (see below). Use boring mind machine! You can test it out and come up with new ideas and ways of using boring mind machine. Open an issue in the boring mind machine repository on Github. The issue can be a bug, a question, an idea, or anything else. Fork boring mind machine on Github!","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#ways-to-contribute","text":"Some ways that you can contribute, in order of increasing involvement: Read the documentation ! If you find a problem or can't understand something, open an issue (see below). Use boring mind machine! You can test it out and come up with new ideas and ways of using boring mind machine. Open an issue in the boring mind machine repository on Github. The issue can be a bug, a question, an idea, or anything else. Fork boring mind machine on Github!","title":"Ways to Contribute"},{"location":"installing/","text":"Installing \u00b6 Installing embarcadero mind machine \u00b6 To install embarcadero mind machine manually, use the normal setup.py procedure: git clone https://github.com/rainbow-mind-machine/embarcadero-mind-machine.git cd embarcadero-mind-machine python setup.py build python setup.py install To install embarcadero mind machine with pip: pip install embarcaderomindmachine Required Packages \u00b6 If you need a list of required packages, see requirements.txt . These packages will be installed using either of the above installation methods.","title":"Installing bmm"},{"location":"installing/#installing","text":"","title":"Installing"},{"location":"installing/#installing-embarcadero-mind-machine","text":"To install embarcadero mind machine manually, use the normal setup.py procedure: git clone https://github.com/rainbow-mind-machine/embarcadero-mind-machine.git cd embarcadero-mind-machine python setup.py build python setup.py install To install embarcadero mind machine with pip: pip install embarcaderomindmachine","title":"Installing embarcadero mind machine"},{"location":"installing/#required-packages","text":"If you need a list of required packages, see requirements.txt . These packages will be installed using either of the above installation methods.","title":"Required Packages"},{"location":"quickstart/","text":"Quick Start with Boring Mind Machine \u00b6 Here is a bare minimum example import boringmindmachine as bmm import os, tempfile token_var = 'token' secret_var = 'secret' keys_json = \"fake_apikeys.json\" keypath = os.path.join(os.getcwd(),keys_json) bk = bmm.BoringOAuthKeymaker(token=token_var, secret=secret_var) bk.set_apikeys_file(keypath) From here, the next step is to start creating derived classes - custom keymakers for various services like Twitter ( rainbow-mind-machine ) or Github ( embarcadero-mind-machine ), and to create custom Shepherd or Sheep classes to set up and run the bot flock. See the examples/ directory for additional examples.","title":"Quick Start"},{"location":"quickstart/#quick-start-with-boring-mind-machine","text":"Here is a bare minimum example import boringmindmachine as bmm import os, tempfile token_var = 'token' secret_var = 'secret' keys_json = \"fake_apikeys.json\" keypath = os.path.join(os.getcwd(),keys_json) bk = bmm.BoringOAuthKeymaker(token=token_var, secret=secret_var) bk.set_apikeys_file(keypath) From here, the next step is to start creating derived classes - custom keymakers for various services like Twitter ( rainbow-mind-machine ) or Github ( embarcadero-mind-machine ), and to create custom Shepherd or Sheep classes to set up and run the bot flock. See the examples/ directory for additional examples.","title":"Quick Start with Boring Mind Machine"},{"location":"mind-machine-docs/about/","text":"Mind Machine Framework \u00b6 The mind machine framework is designed to be a simple, extensible framework for developing bots. How is it simple? \u00b6 The mind machine concept is simple because there are only three components: Keymaker Sheep Shepherd These are the three types of objects that you deal with in any given mind machine (and you should not have to deal with the Keymaker much). How is it extensible? \u00b6 The concept of \"extensible\" refers specifically to the use of inheritance and extended classes. We want to keep things as simple as possible, but also build functionality up into complicated bots. Using base classes and extending one bit at a time helps us accomplish that. How is it POOP-y? \u00b6 The mind machine libraries are a great illustration of Python Object-Oriented Programming (POOP) in action. These are very POOP-y libraries, in that they use classes to combine minimal functionality into classes. We will point out the many examples of POOP-y behavior when we see them in a particular mind machine example.","title":"About Mind Machine Framework"},{"location":"mind-machine-docs/about/#mind-machine-framework","text":"The mind machine framework is designed to be a simple, extensible framework for developing bots.","title":"Mind Machine Framework"},{"location":"mind-machine-docs/about/#how-is-it-simple","text":"The mind machine concept is simple because there are only three components: Keymaker Sheep Shepherd These are the three types of objects that you deal with in any given mind machine (and you should not have to deal with the Keymaker much).","title":"How is it simple?"},{"location":"mind-machine-docs/about/#how-is-it-extensible","text":"The concept of \"extensible\" refers specifically to the use of inheritance and extended classes. We want to keep things as simple as possible, but also build functionality up into complicated bots. Using base classes and extending one bit at a time helps us accomplish that.","title":"How is it extensible?"},{"location":"mind-machine-docs/about/#how-is-it-poop-y","text":"The mind machine libraries are a great illustration of Python Object-Oriented Programming (POOP) in action. These are very POOP-y libraries, in that they use classes to combine minimal functionality into classes. We will point out the many examples of POOP-y behavior when we see them in a particular mind machine example.","title":"How is it POOP-y?"},{"location":"mind-machine-docs/credits/","text":"Credits \u00b6 Most of the magic in rainbow mind machine happens via the excellent bear/python-twitter library. All of the amazing artwork is available via the Creative Commons License compliments of user @russloar on flickr. Photographs in the embarcadero mind machine library are compliments of @charlesreid1 . Comic of Calvin's Dad in the boring mind machine library is compliments of Bill Watterson , author of Calvin and Hobbes . Also see the Calvin and Hobbes wiki .","title":"Credits"},{"location":"mind-machine-docs/credits/#credits","text":"Most of the magic in rainbow mind machine happens via the excellent bear/python-twitter library. All of the amazing artwork is available via the Creative Commons License compliments of user @russloar on flickr. Photographs in the embarcadero mind machine library are compliments of @charlesreid1 . Comic of Calvin's Dad in the boring mind machine library is compliments of Bill Watterson , author of Calvin and Hobbes . Also see the Calvin and Hobbes wiki .","title":"Credits"},{"location":"mind-machine-docs/dev/","text":"Developer Notes \u00b6 Makefiles \u00b6 The Makefile in each mind machine repository provides rules to help you perform common tasks. There are three types of tasks: Makefile rules run after the first clone of a brand-new mind machine repo Makefile rules run after a fresh clone of an existing mind machine repo Makefile rules for testing, creating, deploying The Prime Number Version System \u00b6 Crash course in the prime number version system: Branches: master - contains stable, tagged releases. Each release is a unique prime number, occurring in ascending order. dev - development branch. All work happens here. feature - feature branch. Feature branches are created from the dev branch, and commits from these feature branches are merged back into the dev branch before they are ultimately added to a mind machine release. prerelease/vP - branch preparing a release of version P (updating docs, fixing tests, etc). release/vP - branch with releases of version P. Workflow: Start from a stable version on master Create branch dev from master (or pull from master into dev if it already exists) Create branch feature from dev (feature branch contains all work on a particular feature) When ready, merge changes from feature into dev Once dev branch is ready for a release, create a pre-release branch prerelease/vP Fill out pre-release checklist and test checklist (see below) Cut new release on branch release/vP Tag, push to Github, upload to PyPI, add to Dockerhub Release Process \u00b6 The following checklists help in preparing for releases on PyPI or Dockerhub. Releases happen in a two-step process. Pre-Release Checklist \u00b6 A new release happens when the code is stable. The first step in the release process is to create a pre-release branch, where the code base can be modified but the modifications will generally be specific to the version being released. (For example, updating the version number in setup.py ). Pre-release checklist: setup.py tasks: Does setup.py build work without errors? Does setup.py install work without errors? Has the description in setup.py been defined and updated? Have the requirements in setup.py been changed, and do they match the requirements in requirements.txt ? Does this mind machine properly depend on the correct, new version of boring mind machine? Has the version number in setup.py been bumped? Documentation tasks: Has the version number in the documentation (shield on docs/index.md page) been updated? Has Readme ben updated/quickstart instructions tested? Git tasks: Is the submodule using HTTPS? (should not use SSH) Have submodules been updated? git submodule foreach git checkout master; git submodule foreach git pull origin master Does this release include any large files? Are they necessary? Can they be slimmed? Docker tasks: Is the Dockerfile cloning the repo from the correct URL? Can a simple (non-mind-machine) python-alpine Dockerfile install the requirements in requirements.txt ? Tests Checklist \u00b6 The second step is to go through the build, run, and test process. Test checklist: Nose tests Does python setup.py test pass? Docker Can the Docker container be created using the shell script? Does python setup.py test pass inside the container? Documentation Does mkdocs build work? Is updated documentation ready to deploy? Create Release Branch \u00b6 Once the release checklist has been completed and everything is passing tests, the prerelease branch should be made into a release branch. This can be done by renaming the prerelease branch, git branch -m prereleases/vXYZ releases/vXYZ or by creating a new releases branch from the prerelases branch: git branch releases/vXYZ git checkout releases/vXYZ Create Tags \u00b6 After the new releases branch is created, a tag should be created that points to the head commit of the release branch. Create a git tag: git tag vXYZ.0 git push origin vXYZ.0 This will add the new version tag to the \"Releases\" page of the package's Github repository Testing Release from Github \u00b6 Test downloading anad installing the new release from Github: wget https://github.com/rainbow-mind-machine/boring-mind-machine/archive/vXYZ.zip unzip vXYZ.zip ...see installation instructions... Set Up PyPI Account \u00b6 Ensure you have a PyPI account before you upload the new release to PyPI and make it pip-installable. To set up an account on PyPI: python setup.py register add the following to ~/.pypirc: ~/.pypirc : [distutils] index-servers = pypi [pypi] username:charlesreid1 password:YOURPASSWORDHERE Upload Release to PyPI \u00b6 PyPI = Python Package Index (where pip looks by default) When ready, the steps to release on PyPI are as follows: Create a distribution locally Upload the distribution to PyPI Test the new release in a virtual environment Start by making a distribution package bundle: $ python setup.py sdist Upload it to pypi: $ python setup.py sdist upload Test it out with virutalenv: $ virtualenv vp && cd vp $ source bin/activate $ bin/pip install boringmindmachine Set Up Dockerhub Account \u00b6 Before updating the latest container image available for the project on Dockerhub, you should create a Dockerhub account. There is no command line interface needed, as Dockerhub builds are configured via the web interface and webhooks. Update Container Image on Dockerhub \u00b6 To update the latest container image available for the project on Dockerhub, add the new version's tag to the list of versions that Dockerhub will build. You can also configure webhooks so that new images are built whenever a particular branch is updated, but tagged versions won't change much so they only require building once. Useful Links \u00b6 Guide to packaging a minimal Python application: http://python-packaging.readthedocs.io/en/latest/minimal.html Uploading distributions to PyPI: https://packaging.python.org/guides/migrating-to-pypi-org/#uploading Example scripts and guide: https://gist.github.com/gboeing/dcfaf5e13fad16fc500717a3a324ec17","title":"Developer Notes"},{"location":"mind-machine-docs/dev/#developer-notes","text":"","title":"Developer Notes"},{"location":"mind-machine-docs/dev/#makefiles","text":"The Makefile in each mind machine repository provides rules to help you perform common tasks. There are three types of tasks: Makefile rules run after the first clone of a brand-new mind machine repo Makefile rules run after a fresh clone of an existing mind machine repo Makefile rules for testing, creating, deploying","title":"Makefiles"},{"location":"mind-machine-docs/dev/#the-prime-number-version-system","text":"Crash course in the prime number version system: Branches: master - contains stable, tagged releases. Each release is a unique prime number, occurring in ascending order. dev - development branch. All work happens here. feature - feature branch. Feature branches are created from the dev branch, and commits from these feature branches are merged back into the dev branch before they are ultimately added to a mind machine release. prerelease/vP - branch preparing a release of version P (updating docs, fixing tests, etc). release/vP - branch with releases of version P. Workflow: Start from a stable version on master Create branch dev from master (or pull from master into dev if it already exists) Create branch feature from dev (feature branch contains all work on a particular feature) When ready, merge changes from feature into dev Once dev branch is ready for a release, create a pre-release branch prerelease/vP Fill out pre-release checklist and test checklist (see below) Cut new release on branch release/vP Tag, push to Github, upload to PyPI, add to Dockerhub","title":"The Prime Number Version System"},{"location":"mind-machine-docs/dev/#release-process","text":"The following checklists help in preparing for releases on PyPI or Dockerhub. Releases happen in a two-step process.","title":"Release Process"},{"location":"mind-machine-docs/dev/#pre-release-checklist","text":"A new release happens when the code is stable. The first step in the release process is to create a pre-release branch, where the code base can be modified but the modifications will generally be specific to the version being released. (For example, updating the version number in setup.py ). Pre-release checklist: setup.py tasks: Does setup.py build work without errors? Does setup.py install work without errors? Has the description in setup.py been defined and updated? Have the requirements in setup.py been changed, and do they match the requirements in requirements.txt ? Does this mind machine properly depend on the correct, new version of boring mind machine? Has the version number in setup.py been bumped? Documentation tasks: Has the version number in the documentation (shield on docs/index.md page) been updated? Has Readme ben updated/quickstart instructions tested? Git tasks: Is the submodule using HTTPS? (should not use SSH) Have submodules been updated? git submodule foreach git checkout master; git submodule foreach git pull origin master Does this release include any large files? Are they necessary? Can they be slimmed? Docker tasks: Is the Dockerfile cloning the repo from the correct URL? Can a simple (non-mind-machine) python-alpine Dockerfile install the requirements in requirements.txt ?","title":"Pre-Release Checklist"},{"location":"mind-machine-docs/dev/#tests-checklist","text":"The second step is to go through the build, run, and test process. Test checklist: Nose tests Does python setup.py test pass? Docker Can the Docker container be created using the shell script? Does python setup.py test pass inside the container? Documentation Does mkdocs build work? Is updated documentation ready to deploy?","title":"Tests Checklist"},{"location":"mind-machine-docs/dev/#create-release-branch","text":"Once the release checklist has been completed and everything is passing tests, the prerelease branch should be made into a release branch. This can be done by renaming the prerelease branch, git branch -m prereleases/vXYZ releases/vXYZ or by creating a new releases branch from the prerelases branch: git branch releases/vXYZ git checkout releases/vXYZ","title":"Create Release Branch"},{"location":"mind-machine-docs/dev/#create-tags","text":"After the new releases branch is created, a tag should be created that points to the head commit of the release branch. Create a git tag: git tag vXYZ.0 git push origin vXYZ.0 This will add the new version tag to the \"Releases\" page of the package's Github repository","title":"Create Tags"},{"location":"mind-machine-docs/dev/#testing-release-from-github","text":"Test downloading anad installing the new release from Github: wget https://github.com/rainbow-mind-machine/boring-mind-machine/archive/vXYZ.zip unzip vXYZ.zip ...see installation instructions...","title":"Testing Release from Github"},{"location":"mind-machine-docs/dev/#set-up-pypi-account","text":"Ensure you have a PyPI account before you upload the new release to PyPI and make it pip-installable. To set up an account on PyPI: python setup.py register add the following to ~/.pypirc: ~/.pypirc : [distutils] index-servers = pypi [pypi] username:charlesreid1 password:YOURPASSWORDHERE","title":"Set Up PyPI Account"},{"location":"mind-machine-docs/dev/#upload-release-to-pypi","text":"PyPI = Python Package Index (where pip looks by default) When ready, the steps to release on PyPI are as follows: Create a distribution locally Upload the distribution to PyPI Test the new release in a virtual environment Start by making a distribution package bundle: $ python setup.py sdist Upload it to pypi: $ python setup.py sdist upload Test it out with virutalenv: $ virtualenv vp && cd vp $ source bin/activate $ bin/pip install boringmindmachine","title":"Upload Release to PyPI"},{"location":"mind-machine-docs/dev/#set-up-dockerhub-account","text":"Before updating the latest container image available for the project on Dockerhub, you should create a Dockerhub account. There is no command line interface needed, as Dockerhub builds are configured via the web interface and webhooks.","title":"Set Up Dockerhub Account"},{"location":"mind-machine-docs/dev/#update-container-image-on-dockerhub","text":"To update the latest container image available for the project on Dockerhub, add the new version's tag to the list of versions that Dockerhub will build. You can also configure webhooks so that new images are built whenever a particular branch is updated, but tagged versions won't change much so they only require building once.","title":"Update Container Image on Dockerhub"},{"location":"mind-machine-docs/dev/#useful-links","text":"Guide to packaging a minimal Python application: http://python-packaging.readthedocs.io/en/latest/minimal.html Uploading distributions to PyPI: https://packaging.python.org/guides/migrating-to-pypi-org/#uploading Example scripts and guide: https://gist.github.com/gboeing/dcfaf5e13fad16fc500717a3a324ec17","title":"Useful Links"},{"location":"mind-machine-docs/keymaker/","text":"The Keymaker \u00b6 the mind machine keymaker. trust it with your keys. The Keymaker is the object that is used to authenticate with the third party service and generate the bot keys the application needs to do things on behalf of a user account. This document provides a high-level overview of the Keymaker. Using the Keymaker \u00b6 If you don't care about all of this business and just want to know how to use the keymaker, see the boring mind machine documentation . Specifically, see coverage of the BoringOAuthKeymaker class, along with the service-specific Github Keymaker , Google Keymaker , and Twitter Keymaker classes. Background: The Three-Legged OAuth Process \u00b6 In theory, not all Keymakers must do OAuth, but in practice, all Keymakers do OAuth . The Keymaker carries out a one-time authorization step that needs to be done once for each Sheep = bot = account. The Keymaker will be given a set of \"items\" (more on this in a moment), with one item = one Sheep = one bot = one account, etc. The Keymaker iterates through each item and performs the three-legged OAuth process. Here's a summary of the process: The three legs are: the user (the bot account), the third party service (Github/Google/Twitter/other), and the consumer (your mind machine app - specifically, the Keymaker component) The Keymaker will initiate the process by requesting an OAuth URL from the third party (this is how an app asks a user for permission to access their account) Third party will return an OAuth URL to the Keymaker, which will pass it to the user The user will open the URL in their browser, and sign in using a bot account Third party will verify the credentials of the user, and create a temporary token This token is returned to the API application (via callback URL/other mechanism) API application sends the token to the third party, which verifies the token matches Third party gives the API application a new OAuth token. This is the magic token that allows the OAuth application to do things with the bot account. Why the song and dance? The three-legged authentication process is intended to allow API applications to verify a user's identity (i.e., yes this user actually granted permission for the API application to control their account) without having to handle sensitive data like a user's hashed password. It also keeps the third party in control of the process. Keymaker Credentials \u00b6 Keymaker Input: API Keys \u00b6 There are two pieces of information that are required to do things as your API application (independent of any bot accounts): API application key API application secret key These are the two pieces of information that are required to prove to the third party service that you are the actual owner of your application. Each service stores these pieces of information in different ways, and calls them by different names. For example: Client key/client secret key Consumer token/consumer token secret API token/API secret token etc... The boring mind machine library provides a base OAuth Keymaker class called BoringOAuthKeymaker. This class implements the OAuth process in a generic way. The details specific to the third party service are then implemented in child classes (e.g., GithubKeymaker). Keymaker Output: OAuth Keys \u00b6 In general, the Keymaker creates a set of bot account keys corresponding to a set of items. Once the Keymaker and the user go through the three-legged authentication process for one bot account, the Keymaker will create a JSON file with the bot key so that it can be used again in the future. The bot key contains both the API keys for the application, and the OAuth keys for the bot account.","title":"Keymaker"},{"location":"mind-machine-docs/keymaker/#the-keymaker","text":"the mind machine keymaker. trust it with your keys. The Keymaker is the object that is used to authenticate with the third party service and generate the bot keys the application needs to do things on behalf of a user account. This document provides a high-level overview of the Keymaker.","title":"The Keymaker"},{"location":"mind-machine-docs/keymaker/#using-the-keymaker","text":"If you don't care about all of this business and just want to know how to use the keymaker, see the boring mind machine documentation . Specifically, see coverage of the BoringOAuthKeymaker class, along with the service-specific Github Keymaker , Google Keymaker , and Twitter Keymaker classes.","title":"Using the Keymaker"},{"location":"mind-machine-docs/keymaker/#background-the-three-legged-oauth-process","text":"In theory, not all Keymakers must do OAuth, but in practice, all Keymakers do OAuth . The Keymaker carries out a one-time authorization step that needs to be done once for each Sheep = bot = account. The Keymaker will be given a set of \"items\" (more on this in a moment), with one item = one Sheep = one bot = one account, etc. The Keymaker iterates through each item and performs the three-legged OAuth process. Here's a summary of the process: The three legs are: the user (the bot account), the third party service (Github/Google/Twitter/other), and the consumer (your mind machine app - specifically, the Keymaker component) The Keymaker will initiate the process by requesting an OAuth URL from the third party (this is how an app asks a user for permission to access their account) Third party will return an OAuth URL to the Keymaker, which will pass it to the user The user will open the URL in their browser, and sign in using a bot account Third party will verify the credentials of the user, and create a temporary token This token is returned to the API application (via callback URL/other mechanism) API application sends the token to the third party, which verifies the token matches Third party gives the API application a new OAuth token. This is the magic token that allows the OAuth application to do things with the bot account. Why the song and dance? The three-legged authentication process is intended to allow API applications to verify a user's identity (i.e., yes this user actually granted permission for the API application to control their account) without having to handle sensitive data like a user's hashed password. It also keeps the third party in control of the process.","title":"Background: The Three-Legged OAuth Process"},{"location":"mind-machine-docs/keymaker/#keymaker-credentials","text":"","title":"Keymaker Credentials"},{"location":"mind-machine-docs/keymaker/#keymaker-input-api-keys","text":"There are two pieces of information that are required to do things as your API application (independent of any bot accounts): API application key API application secret key These are the two pieces of information that are required to prove to the third party service that you are the actual owner of your application. Each service stores these pieces of information in different ways, and calls them by different names. For example: Client key/client secret key Consumer token/consumer token secret API token/API secret token etc... The boring mind machine library provides a base OAuth Keymaker class called BoringOAuthKeymaker. This class implements the OAuth process in a generic way. The details specific to the third party service are then implemented in child classes (e.g., GithubKeymaker).","title":"Keymaker Input: API Keys"},{"location":"mind-machine-docs/keymaker/#keymaker-output-oauth-keys","text":"In general, the Keymaker creates a set of bot account keys corresponding to a set of items. Once the Keymaker and the user go through the three-legged authentication process for one bot account, the Keymaker will create a JSON file with the bot key so that it can be used again in the future. The bot key contains both the API keys for the application, and the OAuth keys for the bot account.","title":"Keymaker Output: OAuth Keys"},{"location":"mind-machine-docs/sheep/","text":"The Sheep \u00b6 The mind machine sheep. The Sheep is the component of the bot flock that actually performs the actions using the bot accounts. The Shepherd will instruct each Sheep to start performing an action - either in parallel (if it is a \"forever\" action like tweeting) or in serial (if it is a \"one-time\" action, like changing the bot user's profile). Each Sheep uses a bot key (created by the Keymaker and loaded by the Shepherd) to create an API instance in the constructor. Each Sheep then uses that API instance to perform actions. The BoringSheep base class in boring mind machine defines a generic dispatcher method (which turns strings into function calls) to allow Shepherds to call particular actions for each Sheep. Defining Actions \u00b6 To define an action, define a method for that action. (For example, to define a tweet action, make a tweet() method in the Sheep class you are using.) To control how the action works and introduce variation, you can pass extra parameters (in the form of keyword arguments) to the action method, and the Shepherd will pass those along to the Sheep. The general pattern this follows is: set up or point to an API endpoint create or use the API client object to call the API endpoint process the results","title":"Sheep"},{"location":"mind-machine-docs/sheep/#the-sheep","text":"The mind machine sheep. The Sheep is the component of the bot flock that actually performs the actions using the bot accounts. The Shepherd will instruct each Sheep to start performing an action - either in parallel (if it is a \"forever\" action like tweeting) or in serial (if it is a \"one-time\" action, like changing the bot user's profile). Each Sheep uses a bot key (created by the Keymaker and loaded by the Shepherd) to create an API instance in the constructor. Each Sheep then uses that API instance to perform actions. The BoringSheep base class in boring mind machine defines a generic dispatcher method (which turns strings into function calls) to allow Shepherds to call particular actions for each Sheep.","title":"The Sheep"},{"location":"mind-machine-docs/sheep/#defining-actions","text":"To define an action, define a method for that action. (For example, to define a tweet action, make a tweet() method in the Sheep class you are using.) To control how the action works and introduce variation, you can pass extra parameters (in the form of keyword arguments) to the action method, and the Shepherd will pass those along to the Sheep. The general pattern this follows is: set up or point to an API endpoint create or use the API client object to call the API endpoint process the results","title":"Defining Actions"},{"location":"mind-machine-docs/shepherd/","text":"The Shepherd \u00b6 The shepherd's ( pasteur ) power manifests itself, therefore, in a duty, a task to be undertaken, so that - and I think this is also an important characteristic of pastoral power - the form it takes is not first of all the striking display of strength and superiority. Pastoral power initially manifests itself in its zeal, devotion, and endless application. What is the shepherd ( berger )? Is (s)he someone whose strength strikes people's eyes, like the sovereigns or gods, like the Greek gods, who essentially appear in their splendor? Not at all. The shepherd is someone who keeps watch. (S)he \"keeps watch\" in the sense, of course, of keeping an eye out for possible evils, but above all in the sense of vigilance with regard to any possible misfortune. Michel Foucault, Security, Territory, Population: Lectures at the Coll\u00e9ge de France (1977-1978) The mind machine shepherd. credit what is the Shepherd? \u00b6 The Shepherd is a very simple object. The Shepherd is a data container for storing Sheep. when does the Shepherd come in? \u00b6 The first thing a bot flock needs is a set of keys. That's what the Keymaker is for. Once the bot flock keys have been created with the Keymaker, the bot flock is started. To do that, the Shepherd initializes each Sheep with a corresponding JSON key file (created by the Keymaker). how does the Shepherd tend to the Sheep? \u00b6 In general, the Shepherd is a free-range parent, and lets the Sheep go off and do their own thing. Note however, that in the spirit of extensibility, you can extend the Shepherd and Sheep classes to change the nature of your bot flock. (See next section.) when and how do you extend the Shepherd? \u00b6 The Shepherd class determines how much coordination happens among different Sheep in the flock and between the flock and the outside world (the Internet). Let's look at some simple examples of when you would need to extend the Shepherd class, and what modifications would be required. storing custom parameters \u00b6 First, let's mention a feature of the Shepherd that makes adding new parameters to extended versions of the Shepherd class really simple. The Shepherd constructor __init__() includes a **kwargs argument at the end. This will create a dictionary called kwargs with any key-value pairs the user passed in. This is stored in self.params at the end of the constructor: self.params = kwargs This means that if you create a new Shepherd class like CarMechanicShepherd , and you need to pass in (say) a boolean input parameter like uses_metric , you don't have to explicitly modify the constructor to take uses_metric as a parameter; the Shepherd class automatically adds a key uses_metric with a value True||False to a dictionary self.params when you call the constructor like CarMechanicShepherd(uses_metric=False) Okay, back to the regularly scheduled program... webhook bot flock \u00b6 As an example of a bot flock that requires tighter integration between the Shepherd and the Sheep, imagine you want to create a bot fock where the bots can be controlled with webhooks. You would need the Shepherd to act as a central dispatcher and process incoming webhooks to determine which webhook payloads to pass on to which Sheep. But the Sheep also need to be modified to listen for instructions from the Shepherd. To modify the Shepherd class, we would add a method that listens for incoming webhooks, and a method or methods implementing logic about which payloads to pass along to which Sheep (or to call the appropriate functions when webhooks trigger flock-wide actions). To modify the Sheep class, we would add a listen() method that would run forever - ideally in parallel with other run-forever methods. two bots per key flock \u00b6 Suppose we wanted to build an argument bot flock. This bot flock would consist of pairs of Sheep that use Queneau generation to create dialogue, and that argue back and forth forever with each other. This bot flock modifies the way that our Sheep coordinate with each other, which is an indication we should change the Shepherd class. The Sheep bots we will use will work identically to a normal Queneau Sheep bot. Each bot generates dialogue from a single speaker, and tweets it in response to another bot tweeting. While we could extend the Sheep class to control the dialogue, it would be easier to use the inner/outer loop structure that the QueneauSheep class already has. That way, the Sheep do not require any extending. The Shepherd class needs to be modified by changing the way it instantiates bots from keys. Instead of creating one bot per key, it should create two bots per keys. (Note that the user will need to provide relevant details in the key or config dictionaries. For example, name and handle of both bot sides, inner/outer loop timing, etc.) The -setup_keys() method will not change, because we want to maintain the consistency of one key file corresponding to one bot corresponding to one Twitter account. The _setup_sheep() method would be modified from its current arrangement (pseudocode): current _setup_sheep() method: for json in list-of-all-json-files: create new sheep from json add new sheep to flock to something more like (pseudocode): new _setup_sheep() method: for (bot1, bot2) in list-of-all-bot-pairs: get key1 from keys create bot1 from key1 get key2 from keys create bot2 from key2 link bot1 and bot2 add bot1 and bot2 to flock In this case, we want to have two Queneau Sheep that work almost exactly the same as normal Queneau Sheep, with perhaps a slight modification to make sure that each bot generates dialogue from a single speaker corresponding to their party in the argument.","title":"Shepherd"},{"location":"mind-machine-docs/shepherd/#the-shepherd","text":"The shepherd's ( pasteur ) power manifests itself, therefore, in a duty, a task to be undertaken, so that - and I think this is also an important characteristic of pastoral power - the form it takes is not first of all the striking display of strength and superiority. Pastoral power initially manifests itself in its zeal, devotion, and endless application. What is the shepherd ( berger )? Is (s)he someone whose strength strikes people's eyes, like the sovereigns or gods, like the Greek gods, who essentially appear in their splendor? Not at all. The shepherd is someone who keeps watch. (S)he \"keeps watch\" in the sense, of course, of keeping an eye out for possible evils, but above all in the sense of vigilance with regard to any possible misfortune. Michel Foucault, Security, Territory, Population: Lectures at the Coll\u00e9ge de France (1977-1978) The mind machine shepherd. credit","title":"The Shepherd"},{"location":"mind-machine-docs/shepherd/#what-is-the-shepherd","text":"The Shepherd is a very simple object. The Shepherd is a data container for storing Sheep.","title":"what is the Shepherd?"},{"location":"mind-machine-docs/shepherd/#when-does-the-shepherd-come-in","text":"The first thing a bot flock needs is a set of keys. That's what the Keymaker is for. Once the bot flock keys have been created with the Keymaker, the bot flock is started. To do that, the Shepherd initializes each Sheep with a corresponding JSON key file (created by the Keymaker).","title":"when does the Shepherd come in?"},{"location":"mind-machine-docs/shepherd/#how-does-the-shepherd-tend-to-the-sheep","text":"In general, the Shepherd is a free-range parent, and lets the Sheep go off and do their own thing. Note however, that in the spirit of extensibility, you can extend the Shepherd and Sheep classes to change the nature of your bot flock. (See next section.)","title":"how does the Shepherd tend to the Sheep?"},{"location":"mind-machine-docs/shepherd/#when-and-how-do-you-extend-the-shepherd","text":"The Shepherd class determines how much coordination happens among different Sheep in the flock and between the flock and the outside world (the Internet). Let's look at some simple examples of when you would need to extend the Shepherd class, and what modifications would be required.","title":"when and how do you extend the Shepherd?"},{"location":"mind-machine-docs/shepherd/#storing-custom-parameters","text":"First, let's mention a feature of the Shepherd that makes adding new parameters to extended versions of the Shepherd class really simple. The Shepherd constructor __init__() includes a **kwargs argument at the end. This will create a dictionary called kwargs with any key-value pairs the user passed in. This is stored in self.params at the end of the constructor: self.params = kwargs This means that if you create a new Shepherd class like CarMechanicShepherd , and you need to pass in (say) a boolean input parameter like uses_metric , you don't have to explicitly modify the constructor to take uses_metric as a parameter; the Shepherd class automatically adds a key uses_metric with a value True||False to a dictionary self.params when you call the constructor like CarMechanicShepherd(uses_metric=False) Okay, back to the regularly scheduled program...","title":"storing custom parameters"},{"location":"mind-machine-docs/shepherd/#webhook-bot-flock","text":"As an example of a bot flock that requires tighter integration between the Shepherd and the Sheep, imagine you want to create a bot fock where the bots can be controlled with webhooks. You would need the Shepherd to act as a central dispatcher and process incoming webhooks to determine which webhook payloads to pass on to which Sheep. But the Sheep also need to be modified to listen for instructions from the Shepherd. To modify the Shepherd class, we would add a method that listens for incoming webhooks, and a method or methods implementing logic about which payloads to pass along to which Sheep (or to call the appropriate functions when webhooks trigger flock-wide actions). To modify the Sheep class, we would add a listen() method that would run forever - ideally in parallel with other run-forever methods.","title":"webhook bot flock"},{"location":"mind-machine-docs/shepherd/#two-bots-per-key-flock","text":"Suppose we wanted to build an argument bot flock. This bot flock would consist of pairs of Sheep that use Queneau generation to create dialogue, and that argue back and forth forever with each other. This bot flock modifies the way that our Sheep coordinate with each other, which is an indication we should change the Shepherd class. The Sheep bots we will use will work identically to a normal Queneau Sheep bot. Each bot generates dialogue from a single speaker, and tweets it in response to another bot tweeting. While we could extend the Sheep class to control the dialogue, it would be easier to use the inner/outer loop structure that the QueneauSheep class already has. That way, the Sheep do not require any extending. The Shepherd class needs to be modified by changing the way it instantiates bots from keys. Instead of creating one bot per key, it should create two bots per keys. (Note that the user will need to provide relevant details in the key or config dictionaries. For example, name and handle of both bot sides, inner/outer loop timing, etc.) The -setup_keys() method will not change, because we want to maintain the consistency of one key file corresponding to one bot corresponding to one Twitter account. The _setup_sheep() method would be modified from its current arrangement (pseudocode): current _setup_sheep() method: for json in list-of-all-json-files: create new sheep from json add new sheep to flock to something more like (pseudocode): new _setup_sheep() method: for (bot1, bot2) in list-of-all-bot-pairs: get key1 from keys create bot1 from key1 get key2 from keys create bot2 from key2 link bot1 and bot2 add bot1 and bot2 to flock In this case, we want to have two Queneau Sheep that work almost exactly the same as normal Queneau Sheep, with perhaps a slight modification to make sure that each bot generates dialogue from a single speaker corresponding to their party in the argument.","title":"two bots per key flock"}]}